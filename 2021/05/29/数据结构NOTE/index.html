
<!DOCTYPE html>
<html lang="zh-CN,en,default" class="loading">
<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <meta name="viewport" content="width=device-width, minimum-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>数据结构知识笔记 - WHOAMI</title>
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="google" content="notranslate" />
    <meta name="keywords" content="渗透,"> 
    <meta name="description" content="A GEEK HACKER,一、数据结构绪论
基本概念&amp;amp;术语
数据（描述客观事物的符号，能被计算机识别并操作的符号集合）
性质：a.可以输入到计算机中。b.能被计算机程序处理。
数值类型数据：进行数值计算（整型、实型）,"> 
    <meta name="author" content="真のBLACK"> 
    <link rel="alternative" href="atom.xml" title="WHOAMI" type="application/atom+xml"> 
    <link rel="icon" href="/img/favicon.png"> 
    
<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css">

    <meta name="twitter:image:src" content="https://bangdream.moe/img/ident.png"/>
    <meta name="twitter:creator" content="@yourtwitteridhere"/>
    <meta name="twitter:card" content="summary_large_image"/>
    <meta name="twitter:title" content="数据结构知识笔记 - WHOAMI"/>
    <meta name="twitter:description" content="A GEEK HACKER,一、数据结构绪论
基本概念&amp;amp;术语
数据（描述客观事物的符号，能被计算机识别并操作的符号集合）
性质：a.可以输入到计算机中。b.能被计算机程序处理。
数值类型数据：进行数值计算（整型、实型）,"/>
    <meta property="og:image" content="https://bangdream.moe/img/ident.png"/>
    <meta property="og:image:alt" content="A GEEK HACKER,一、数据结构绪论
基本概念&amp;amp;术语
数据（描述客观事物的符号，能被计算机识别并操作的符号集合）
性质：a.可以输入到计算机中。b.能被计算机程序处理。
数值类型数据：进行数值计算（整型、实型）,"/>
    <meta property="og:image:width" content="1200"/>
    <meta property="og:image:height" content="600"/>
    <meta property="og:site_name" content="WHOAMI"/>
    <meta property="og:type" content="object"/>
    <meta property="og:title" content="数据结构知识笔记 - WHOAMI"/>
    <meta property="og:description" content="A GEEK HACKER,一、数据结构绪论
基本概念&amp;amp;术语
数据（描述客观事物的符号，能被计算机识别并操作的符号集合）
性质：a.可以输入到计算机中。b.能被计算机程序处理。
数值类型数据：进行数值计算（整型、实型）,"/>
    
<link rel="stylesheet" href="/css/diaspora.css">

<meta name="generator" content="Hexo 6.3.0"></head>

<body class="loading">
    <span id="config-title" style="display:none">WHOAMI</span>
    <div id="loader"></div>
    <div id="single">
    <div id="top" style="display: block;">
    <div class="bar" style="width: 0;"></div>
    <a class="iconfont icon-home image-icon" href="javascript:;" data-url="https://DXHM.github.io"></a>
    <div title="播放/暂停" class="iconfont icon-play"></div>
    <h3 class="subtitle">数据结构知识笔记</h3>
    <div class="social">
        <div>
            <div class="share">
                <a title="获取二维码" class="iconfont icon-scan" href="javascript:;"></a>
            </div>
            <div id="qr"></div>
        </div>
    </div>
    <div class="scrollbar"></div>
</div>

    <div class="section">
        <div class="article">
    <div class='main'>
        <h1 class="title">数据结构知识笔记</h1>
        <div class="stuff">
            <span>五月 29, 2021</span>
            
  <ul class="post-tags-list" itemprop="keywords"><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" rel="tag">数据结构</a></li><li class="post-tags-list-item"><a class="post-tags-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>


        </div>
        <div class="content markdown">
            <h1 id="一、数据结构绪论"><a href="#一、数据结构绪论" class="headerlink" title="一、数据结构绪论"></a>一、数据结构绪论</h1><ol>
<li><h3 id="基本概念-amp-术语"><a href="#基本概念-amp-术语" class="headerlink" title="基本概念&amp;术语"></a>基本概念&amp;术语</h3><ol>
<li><h4 id="数据（描述客观事物的符号，能被计算机识别并操作的符号集合）"><a href="#数据（描述客观事物的符号，能被计算机识别并操作的符号集合）" class="headerlink" title="数据（描述客观事物的符号，能被计算机识别并操作的符号集合）"></a>数据（描述客观事物的符号，能被计算机识别并操作的符号集合）</h4><ol>
<li>性质：a.可以输入到计算机中。b.能被计算机程序处理。</li>
<li>数值类型数据：进行数值计算（整型、实型）</li>
<li>非数值类型数据：通过编码变成字符数据（字符型、声音、图像、视频等）</li>
</ol>
</li>
<li><h4 id="数据元素（“记录”）：组成数据的基本单位"><a href="#数据元素（“记录”）：组成数据的基本单位" class="headerlink" title="数据元素（“记录”）：组成数据的基本单位"></a>数据元素（“记录”）：组成数据的基本单位</h4></li>
<li><h4 id="数据项：若干数据项组成一个数据元素，是数据不可分割的最小单位"><a href="#数据项：若干数据项组成一个数据元素，是数据不可分割的最小单位" class="headerlink" title="数据项：若干数据项组成一个数据元素，是数据不可分割的最小单位"></a>数据项：若干数据项组成一个数据元素，是<span style="color: red;">数据不可分割的最小单位</span></h4></li>
<li><h4 id="数据对象：数据的子集（相同性质的数据元素的集合）"><a href="#数据对象：数据的子集（相同性质的数据元素的集合）" class="headerlink" title="数据对象：数据的子集（相同性质的数据元素的集合）"></a>数据对象：数据的子集（相同性质的数据元素的集合）</h4></li>
<li><h4 id="数据结构：存在一种或多种特定关系的数据元素的集合"><a href="#数据结构：存在一种或多种特定关系的数据元素的集合" class="headerlink" title="数据结构：存在一种或多种特定关系的数据元素的集合"></a>数据<span style="color: red;">结构</span>：存在一种或多种<span style="color: red;">特定关系</span><strong>的数据元素的集合</strong></h4></li>
</ol>
</li>
<li><h3 id="结构分类"><a href="#结构分类" class="headerlink" title="结构分类"></a>结构分类</h3><ol>
<li><h4 id="存储类型"><a href="#存储类型" class="headerlink" title="存储类型"></a>存储类型</h4><ol>
<li><h5 id="逻辑结构：-面向问题-数据元素之间的关系"><a href="#逻辑结构：-面向问题-数据元素之间的关系" class="headerlink" title="逻辑结构：(面向问题)数据元素之间的关系"></a>逻辑结构：<span style="color: green;">(面向问题)</span>数据元素之间的关系</h5><ol>
<li><h6 id="线性结构：一对一"><a href="#线性结构：一对一" class="headerlink" title="线性结构：一对一"></a>线性结构：一对一</h6></li>
<li><h6 id="非线性结构"><a href="#非线性结构" class="headerlink" title="非线性结构"></a>非线性结构</h6><ol>
<li>集合结构：同属一个集合，没有其他关系（一国+多民族）</li>
<li>树形结构：一对多、层次</li>
<li>图形结构：多对多</li>
</ol>
</li>
</ol>
</li>
<li><h5 id="物理结构：-面向计算机-在计算机中的存储方式"><a href="#物理结构：-面向计算机-在计算机中的存储方式" class="headerlink" title="物理结构：(面向计算机)在计算机中的存储方式"></a>物理结构：<span style="color: green;">(面向计算机)</span>在计算机中的存储方式</h5><ol>
<li>顺序存储结构（连续地址、排队占位）：数据间的<span style="color: blue;">逻辑关系</span>和<span style="color: blue;">物理关系</span>一致</li>
<li>链式存储结构（&#x3D;&#x3D;指针&#x3D;&#x3D;索引、任意存储）</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><ul>
<li><span style="color: blue;">分类方式：</span> <span style="color: blue;">1. 取值范围</span> <span style="color: blue;">2. 所能进行的操作</span></li>
</ul>
<ol>
<li><h5 id="原子类型（不可分解的基本类型）：整型、实型、字符型"><a href="#原子类型（不可分解的基本类型）：整型、实型、字符型" class="headerlink" title="原子类型（不可分解的基本类型）：整型、实型、字符型"></a>原子类型（不可分解的基本类型）：整型、实型、字符型</h5></li>
<li><h5 id="结构类型（可分解组合类型）：结构体"><a href="#结构类型（可分解组合类型）：结构体" class="headerlink" title="结构类型（可分解组合类型）：结构体"></a>结构类型（可分解组合类型）：结构体</h5></li>
<li><h5 id="抽象数据类型-ADT（微元思想）：一个数学模型及定义在该模型上的一组操作"><a href="#抽象数据类型-ADT（微元思想）：一个数学模型及定义在该模型上的一组操作" class="headerlink" title="抽象数据类型 ADT（微元思想）：一个数学模型及定义在该模型上的一组操作"></a>抽象数据类型 ADT（微元思想）：一个<span style="color: red;">数学模型</span>及定义在该模型上的一组操作</h5></li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="二、算法"><a href="#二、算法" class="headerlink" title="二、算法"></a>二、算法</h1><ol>
<li><h4 id="算法的定义："><a href="#算法的定义：" class="headerlink" title="算法的定义："></a>算法的定义：</h4><ol>
<li>算法&#x3D;解法：求解步骤（的描述）</li>
<li>计算机中表现：指令的有限序列，每条指令表示一个或多个操作</li>
</ol>
</li>
<li><h4 id="算法的特性：（五个基本特性）"><a href="#算法的特性：（五个基本特性）" class="headerlink" title="算法的特性：（五个基本特性）"></a>算法的特性：（五个基本特性）</h4><ol>
<li>输入、输出</li>
<li>有穷性</li>
<li>确定性</li>
<li>可行性</li>
</ol>
</li>
<li><h4 id="算法设计的要求："><a href="#算法设计的要求：" class="headerlink" title="算法设计的要求："></a>算法设计的要求：</h4><ol>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>时间效率高+存储量低</li>
</ol>
</li>
<li><h4 id="（算法效率的）度量方法："><a href="#（算法效率的）度量方法：" class="headerlink" title="（算法效率的）度量方法："></a>（算法效率的）度量方法：</h4><ol>
<li>事前分析估算方法：运行时间预估<ol>
<li><span style="color: red;">根本：算法（的好坏）</span></li>
<li><span style="color: red;">问题输入(量)规模</span></li>
<li>&#x3D;&#x3D;软件&#x3D;&#x3D;支持：变异产生的代码质量</li>
<li>&#x3D;&#x3D;硬件&#x3D;&#x3D;性能：机器执行速度</li>
</ol>
</li>
<li>事后统计方法：计算机计时器对不同算法编制运行时间进行比较</li>
</ol>
</li>
<li><h4 id="x3D-x3D-时间复杂度估算效率-x3D-x3D-规范：函数的渐进增长（单调递增）"><a href="#x3D-x3D-时间复杂度估算效率-x3D-x3D-规范：函数的渐进增长（单调递增）" class="headerlink" title="&#x3D;&#x3D;时间复杂度估算效率&#x3D;&#x3D;规范：函数的渐进增长（单调递增）"></a>&#x3D;&#x3D;时间复杂度估算效率&#x3D;&#x3D;规范：函数的<u>渐进增长</u>（单调递增）</h4><ol>
<li>忽略<strong>加法常数</strong></li>
<li>忽略<strong>最高次项的乘积常数</strong></li>
<li>关注<strong>最高次项的指数</strong><span style="color: green;">（指数大，增长快）</span></li>
</ol>
</li>
<li><h4 id="算法时间复杂度"><a href="#算法时间复杂度" class="headerlink" title="算法时间复杂度"></a>算法时间复杂度</h4><ol>
<li><p>算法时间复杂度定义：渐近时间复杂度</p>
</li>
<li><p>【大O记法：O()】推导方法：</p>
<ol>
<li><span style="color: red;"><strong>O(1)</strong></span>取代所有加法常数</li>
<li><span style="color: red;">只保留<strong>最高阶项</strong></span></li>
<li>最高阶项存在且系数不是1，<span style="color: red;"><strong>去除</strong>与这个项<strong>相乘的系数</strong></span></li>
</ol>
</li>
<li><p>常见的时间复杂度：O(1)&lt;O(logn)&lt;O(n)&lt;O(nlogn)&lt;O(n<sup>2</sup>)&lt;O(n<sup>3</sup>)&lt;O(2<sup>n</sup>)&lt;O(n!)&lt;O(n<sup>n</sup>)</p>
</li>
<li><p><span style="color: red;">【最现实】</span>最坏情况&amp;<span style="color: red;">【最理想】</span>平均情况</p>
</li>
<li><p>算法<strong>空间复杂度</strong>：S(n)&#x3D;O(f<sub>(n)</sub>)</p>
</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>阶</th>
<th>非正式术语</th>
</tr>
</thead>
<tbody><tr>
<td>O(1)</td>
<td>常数阶</td>
</tr>
<tr>
<td>O(logn)</td>
<td>对数阶</td>
</tr>
<tr>
<td>O(n)</td>
<td>线性阶</td>
</tr>
<tr>
<td>O(nlogn)</td>
<td>nlogn阶</td>
</tr>
<tr>
<td>O(n<sup>2</sup>)</td>
<td>平方阶</td>
</tr>
<tr>
<td>O(n<sup>3</sup>)</td>
<td>立方阶</td>
</tr>
<tr>
<td>O(2<sup>n</sup>)</td>
<td>指数阶</td>
</tr>
<tr>
<td>O(n!)</td>
<td>乘积阶</td>
</tr>
<tr>
<td>O(n<sup>n</sup>)</td>
<td></td>
</tr>
</tbody></table>
<h1 id="三、线性表"><a href="#三、线性表" class="headerlink" title="三、线性表"></a>三、线性表</h1><ol>
<li><h3 id="线性表（List）的定义：零-x2F-多个数据元素的有限序列"><a href="#线性表（List）的定义：零-x2F-多个数据元素的有限序列" class="headerlink" title="线性表（List）的定义：零&#x2F;多个数据元素的有限序列"></a>线性表（List）的定义：零&#x2F;多个数据元素的<span style="color: red;">有限序列</span></h3><ol>
<li><h4 id="List主要性质："><a href="#List主要性质：" class="headerlink" title="List主要性质："></a>List主要性质：</h4><ol>
<li>是一个有限序列</li>
<li>元素之间是有顺序的</li>
<li>存在&#x3D;&#x3D;直接前驱元素&#x3D;&#x3D;和&#x3D;&#x3D;直接后继元素&#x3D;&#x3D;</li>
<li>第一个元素无前驱，最后一个元素无后继</li>
</ol>
</li>
<li><h4 id="线性表长度：元素个数-n"><a href="#线性表长度：元素个数-n" class="headerlink" title="线性表长度：元素个数 n"></a>线性表长度：元素个数 <span style="color: red;">n</span></h4></li>
<li><h4 id="空表：n-x3D-0"><a href="#空表：n-x3D-0" class="headerlink" title="空表：n&#x3D;0"></a>空表：n&#x3D;0</h4></li>
<li><h4 id="位序：（ai）中的i"><a href="#位序：（ai）中的i" class="headerlink" title="位序：（ai）中的i"></a>位序：（a<span style="color: red;"><sub>i</sub></span>）中的<span style="color: red;">i</span></h4></li>
</ol>
</li>
<li><h3 id="线性表的抽象数据类型"><a href="#线性表的抽象数据类型" class="headerlink" title="线性表的抽象数据类型"></a>线性表的抽象数据类型</h3><ol>
<li><h4 id="传参原则：-传递一个参数给函数时，参数会不会在函数内被改动决定了使用什么传参形式"><a href="#传参原则：-传递一个参数给函数时，参数会不会在函数内被改动决定了使用什么传参形式" class="headerlink" title="传参原则：(传递一个参数给函数时，参数会不会在函数内被改动决定了使用什么传参形式)"></a><span style="color: red;">传参原则</span>：(传递一个参数给函数时，参数会不会在函数内被改动决定了使用什么传参形式)</h4><ol>
<li>如果<strong>需要</strong>被改，&#x3D;&#x3D;传递&#x3D;&#x3D;指向这个参数的&#x3D;&#x3D;指针&#x3D;&#x3D;</li>
<li>如果<strong>不需要</strong>被改，直接&#x3D;&#x3D;传递&#x3D;&#x3D;这个&#x3D;&#x3D;参数&#x3D;&#x3D;</li>
</ol>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ADT List</span><br><span class="line">Data</span><br><span class="line">   对象集合为&#123;a1,a2,...,an&#125;</span><br><span class="line">Operation</span><br><span class="line">   InitList(*L)</span><br><span class="line">   ListEmpty(L)</span><br><span class="line">   ClearList(*L)</span><br><span class="line">   GetElem(L,i,*e)</span><br><span class="line">   LocateElem(L,e)</span><br><span class="line">   ListInsert(*L,i,e)</span><br><span class="line">   ListDelete(*L,i,*e)</span><br><span class="line">   ListLength(L)</span><br><span class="line">   endADT</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="线性表的顺序存储结构"><a href="#线性表的顺序存储结构" class="headerlink" title="线性表的顺序存储结构"></a>线性表的<span style="color: purple;">顺序存储结构</span></h3><ol>
<li><h4 id="定义与性质：用一段-x3D-x3D-地址连续-x3D-x3D-的-x3D-x3D-存储单元-x3D-x3D-依次存储线表的-x3D-x3D-数据元素-x3D-x3D"><a href="#定义与性质：用一段-x3D-x3D-地址连续-x3D-x3D-的-x3D-x3D-存储单元-x3D-x3D-依次存储线表的-x3D-x3D-数据元素-x3D-x3D" class="headerlink" title="定义与性质：用一段&#x3D;&#x3D;地址连续&#x3D;&#x3D;的&#x3D;&#x3D;存储单元&#x3D;&#x3D;依次存储线表的&#x3D;&#x3D;数据元素&#x3D;&#x3D;"></a>定义与性质：用一段&#x3D;&#x3D;地址连续&#x3D;&#x3D;的&#x3D;&#x3D;存储单元&#x3D;&#x3D;<span style="color: red;">依次存储</span>线表的&#x3D;&#x3D;数据元素&#x3D;&#x3D;</h4><ol>
<li><p>存储方式：顺序占位 O(1)</p>
</li>
<li><p>实现方式：一维数组</p>
<ol>
<li><p>估算最大存储容量，建立数组</p>
</li>
<li><p>（固定）数组长度&#x3D;&#x3D;最大存储容量</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 20</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   ElemType data[MAXSIZE];</span><br><span class="line">   <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color: red;">顺序存储结构三属性</span>：</p>
<blockquote>
<p>data：数组data的存储空间初始位置就是存储空间的存储位置</p>
</blockquote>
<blockquote>
<p>MAXSIZE：最大存储容量&#x2F;数组(据)长度</p>
</blockquote>
<blockquote>
<p>int length：当前线性表长度</p>
</blockquote>
</li>
</ol>
</li>
<li><h4 id="地址的计算方法：-x3D-x3D-数据元素的序号-x3D-x3D-与存放的数组-x3D-x3D-下标-x3D-x3D-存在-x3D-x3D-对应-x3D-x3D-关系"><a href="#地址的计算方法：-x3D-x3D-数据元素的序号-x3D-x3D-与存放的数组-x3D-x3D-下标-x3D-x3D-存在-x3D-x3D-对应-x3D-x3D-关系" class="headerlink" title="地址的计算方法：&#x3D;&#x3D;数据元素的序号&#x3D;&#x3D;与存放的数组&#x3D;&#x3D;下标&#x3D;&#x3D;存在&#x3D;&#x3D;对应&#x3D;&#x3D;关系"></a>地址的计算方法：&#x3D;&#x3D;数据元素的序号&#x3D;&#x3D;与存放的数组&#x3D;&#x3D;下标&#x3D;&#x3D;存在&#x3D;&#x3D;对应&#x3D;&#x3D;关系</h4></li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th>data[]（下标）</th>
<th>0</th>
<th>1</th>
<th>…</th>
<th>i-2</th>
<th>i-1</th>
<th>…</th>
<th>n-1</th>
<th>空闲空间</th>
</tr>
</thead>
<tbody><tr>
<td>a<span style="color: red;"><sub>?</sub></span></td>
<td>a<sub>1</sub></td>
<td>a<sub>2</sub></td>
<td>…</td>
<td>a<sub>i-1</sub></td>
<td>a<sub>i</sub></td>
<td>…</td>
<td></td>
<td>a<sub>n</sub></td>
</tr>
</tbody></table>
<ul>
<li>C语言：数组地址从 0 开始，对应数据元素序号为 n-1<ol start="3">
<li><h4 id="顺序存储结构的查找、插入、删除"><a href="#顺序存储结构的查找、插入、删除" class="headerlink" title="顺序存储结构的查找、插入、删除"></a>顺序存储结构的查找、插入、删除</h4></li>
</ol>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">查找获取线性表L中第i个位置（对应data[i-1]）の元素值</span></span><br><span class="line"><span class="comment">时间复杂度：O(1)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OK 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Status;</span><br><span class="line">Status <span class="title function_">GetElem</span><span class="params">(SqList L,<span class="type">int</span> i,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(L.length==<span class="number">0</span> || i&lt;<span class="number">1</span> || i&gt;L.length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;    </span><br><span class="line">    &#125;</span><br><span class="line">    *e=L.data[i<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">插入算法思路：</span></span><br><span class="line"><span class="comment">    1.如果插入位置不合理，抛出异常</span></span><br><span class="line"><span class="comment">    2.如果线性表长度大于等于数组长度，抛出异常或动态扩容</span></span><br><span class="line"><span class="comment">    3.最后一个元素**向前遍历**到第i个位置，分别都后移一个位置</span></span><br><span class="line"><span class="comment">    4.插入元素到i处</span></span><br><span class="line"><span class="comment">    5.length+1</span></span><br><span class="line"><span class="comment">关键点：</span></span><br><span class="line"><span class="comment"> 	a1.第 i 个元素 == data[i-1]</span></span><br><span class="line"><span class="comment">    a2. k 从表倒数第二位循环向前推进覆盖 k+1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(SqList *L,<span class="type">int</span> i,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length==MAXSIZE)	<span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length+<span class="number">1</span>)	<span class="comment">//2</span></span><br><span class="line"> 	&#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;=L-length)		<span class="comment">//3</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=L-&gt;length<span class="number">-1</span>;k&gt;=i<span class="number">-1</span>;k--)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;data[k+<span class="number">1</span>]=L-&gt;data[k];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;data[i<span class="number">-1</span>]=e;	<span class="comment">//4</span></span><br><span class="line">    L-&gt;length++;	<span class="comment">//5</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除算法思路：</span></span><br><span class="line"><span class="comment">    1.异常检测判断：删除位置不合理，抛出异常</span></span><br><span class="line"><span class="comment">    2.取出/记录删除元素</span></span><br><span class="line"><span class="comment">    3.循环覆盖实现删除：从删除元素位置开始遍历到最后一个元素位置，分别向前移动一位</span></span><br><span class="line"><span class="comment">    4.length-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(SqList *L,<span class="type">int</span> i,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    <span class="keyword">if</span>(L-&gt;length==<span class="number">0</span>)	<span class="comment">//空表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;L-&gt;length)	<span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e=L-&gt;data[i<span class="number">-1</span>];	<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(k=i;k&lt;L-&gt;length;k++)</span><br><span class="line">        &#123;</span><br><span class="line">            L-&gt;data[k<span class="number">-1</span>]=L-&gt;data[k];	<span class="comment">//3</span></span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;length--;	<span class="comment">//4</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>读取时间复杂度：O(1)</li>
<li>插入、删除时间复杂度：【平均】O(n)【最坏】O(n)【最好】O(1)</li>
<li>顺序存储优势：<ul>
<li>方便存、取</li>
</ul>
</li>
<li>顺序存储劣势：<ul>
<li>不方便增、删</li>
<li>难以确定存储空间容量</li>
<li>造成存储空间碎片</li>
</ul>
</li>
</ul>
</li>
</ul>
<ol start="4">
<li><h3 id="线性表的链式存储结构"><a href="#线性表的链式存储结构" class="headerlink" title="线性表的链式存储结构"></a>线性表的<span style="color: purple;">链式存储结构</span></h3><ol>
<li><h4 id="链式存储结构的定义：n个结点链结成一个链表"><a href="#链式存储结构的定义：n个结点链结成一个链表" class="headerlink" title="链式存储结构的定义：n个结点链结成一个链表"></a>链式存储结构的定义：n个结点链结成一个链表</h4><ol>
<li>数据域：存储数据元素信息（data）的域</li>
<li>指针域：<strong>存储直接后继</strong>（next）位置的域<ol>
<li>指针&#x2F;链：指针域中存储的信息</li>
<li>最后一节结点的指针域：NULL &#x2F; ^</li>
</ol>
</li>
<li>结点：数据域+指针域&#x3D;数据元素a<sub>i</sub></li>
<li><span style="color: green;">单链表：每个结点只包含一个指针域</span></li>
<li>头指针：<span style="color: red;">（必要元素）</span>指向链表中第一个结点的存储位置</li>
<li>头结点：<span style="color: red;">（非必要元素，为了方便操作）</span>人为设置，置于第一个结点前<span style="color: green;">【数据域：不存储任何信息&#x2F;存储如线表长度等附加信息】【指针域：指向第一个结点的指针】</span></li>
</ol>
</li>
<li><h4 id="链式存储结构-建立单链表"><a href="#链式存储结构-建立单链表" class="headerlink" title="链式存储结构-建立单链表"></a>链式存储结构-建立单链表</h4><ol>
<li><p>（数据域）存放数据元素：a<sub>i</sub>&#x3D;p-&gt;data，a<sub>i+1</sub>&#x3D;p-&gt;next-&gt;data</p>
</li>
<li><p>（指针域）存放一个指针：p-&gt;next</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>	<span class="comment">//指针域（后继）</span></span><br><span class="line">&#125;Node;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="单链表的读取：“工作指针后移”遍历查找（GetElem）"><a href="#单链表的读取：“工作指针后移”遍历查找（GetElem）" class="headerlink" title="单链表的读取：“工作指针后移”遍历查找（GetElem）"></a>单链表的读取：“工作指针后移”遍历查找（GetElem）</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">遍历思路：</span></span><br><span class="line"><span class="comment">    1.声明指针p指向链表第一个结点，初始化计数器j=1</span></span><br><span class="line"><span class="comment">    2.当j&lt;i时，遍历链表，p的指针向后移动，j++</span></span><br><span class="line"><span class="comment">    3.若链表末尾p为空，第i个结点不存在</span></span><br><span class="line"><span class="comment">    4.否则查找成功，返回数据p-&gt;data</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Stuatus <span class="title function_">GetElem</span><span class="params">(LinkList L,<span class="type">int</span> i,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    LinkLisk p;</span><br><span class="line">    p=L-&gt;next;	<span class="comment">//1</span></span><br><span class="line">    j=<span class="number">1</span>;	<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;	<span class="comment">//2</span></span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j&gt;i)	<span class="comment">//3.（不为非空）!p!=0 --&gt; p==0</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    *e=p-&gt;data;	<span class="comment">//4.取出数据p-&gt;data</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="单链表的插入、删除：O-n-【插删操作越频繁，效率优势越明显】"><a href="#单链表的插入、删除：O-n-【插删操作越频繁，效率优势越明显】" class="headerlink" title="单链表的插入、删除：O(n)【插删操作越频繁，效率优势越明显】"></a>单链表的插入、删除：O(n)【插删操作越频繁，效率优势越明显】</h4><ol>
<li><p>插入：覆盖指针域<span style="color: red;">（先右后左）</span> <code>s-&gt;next = p-&gt;next;</code> <code>p-&gt;next = s;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">插入算法思路：</span></span><br><span class="line"><span class="comment">    1.声明指针p指向链头，初始化计数器j=1</span></span><br><span class="line"><span class="comment">    2.异常判断，指针p循环遍历到第i位，j++</span></span><br><span class="line"><span class="comment">    3.若链表末尾p为空，说明第i个结点不存在</span></span><br><span class="line"><span class="comment">    4.否则查找成功，动态扩容生成一个空节点s</span></span><br><span class="line"><span class="comment">    5.**数据元素e赋值给s-&gt;data**</span></span><br><span class="line"><span class="comment">    6.**覆盖插入指针域**</span></span><br><span class="line"><span class="comment">    7.return OK;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(LinkList *L,<span class="type">int</span> i,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    LinkList p,s;</span><br><span class="line">    p = *L;	<span class="comment">//1.指向链头</span></span><br><span class="line">    j = <span class="number">1</span>;	<span class="comment">//1.计数器</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i)	<span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!p || j&gt;i)	<span class="comment">//3</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    s=(LiskList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));	<span class="comment">//4.malloc()</span></span><br><span class="line">    s-&gt;data = e;	<span class="comment">//5</span></span><br><span class="line">    s-&gt;next = p-&gt;next;	<span class="comment">//6</span></span><br><span class="line">    p-&gt;next = s;	<span class="comment">//6</span></span><br><span class="line">    <span class="keyword">return</span> OK;	<span class="comment">//7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除：<span style="color: red;">后继的后继结点</span>覆盖<span style="color: red;">后继节点</span> <code>q = p-&gt;next;</code> <code>p-next = q-&gt;next; //p-&gt;next-&gt;next;</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除算法思路：</span></span><br><span class="line"><span class="comment">    1.声明指针p指向表头，初始化计数器j=1</span></span><br><span class="line"><span class="comment">    2.j&lt;i，p指针循环遍历链表到i-1，j++</span></span><br><span class="line"><span class="comment">    3.异常检测：若链表末尾p为空，说明i结点不存在</span></span><br><span class="line"><span class="comment">    4.**否则查找成功，取出后继节点p-&gt;next赋值给q**</span></span><br><span class="line"><span class="comment">    5.**后继的后继q-next结点覆盖后继节点p-&gt;next**</span></span><br><span class="line"><span class="comment">    6.q结点中数据赋值给返回值e</span></span><br><span class="line"><span class="comment">    7.释放q结点【free();】</span></span><br><span class="line"><span class="comment">    8.return OK;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(LinkList *L,<span class="type">int</span> i,ElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    LinkList p,q;</span><br><span class="line">    p = *L;	<span class="comment">//1</span></span><br><span class="line">    j = <span class="number">1</span>;	<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">while</span>(p &amp;&amp; j&lt;i)	<span class="comment">//2.p指针循环遍历移动到第i-1个元素</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">        ++j;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!(p-&gt;next) || j&gt;i)	<span class="comment">//3.异常检测</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    q = p-&gt;next;	<span class="comment">//4</span></span><br><span class="line">    p-&gt;next = q-&gt;next;	<span class="comment">//5</span></span><br><span class="line">    *e = q-&gt;data;	<span class="comment">//6</span></span><br><span class="line">    <span class="built_in">free</span>(q);	<span class="comment">//7</span></span><br><span class="line">    <span class="keyword">return</span> OK;	<span class="comment">//8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="单链表的整表创建：动态生成链表的过程"><a href="#单链表的整表创建：动态生成链表的过程" class="headerlink" title="单链表的整表创建：动态生成链表的过程"></a>单链表的整表创建：动态生成链表的过程</h4><ol>
<li><p><span style="color: red;">头插法</span>创建：（在头结点后面）<strong>循环插入，向后延伸</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">头插法创建思路：</span></span><br><span class="line"><span class="comment">    1.声明指针p和计数器j</span></span><br><span class="line"><span class="comment">    （初始化随机数发生器）</span></span><br><span class="line"><span class="comment">    2.创建一个只有头结点的单链表，L头结点指针指向NULL</span></span><br><span class="line"><span class="comment">    3.循环生成结点，接在头结点后面延伸</span></span><br><span class="line"><span class="comment">        a.生成新结点赋值给p</span></span><br><span class="line"><span class="comment">        b.随机生成数据赋值给 p的数据域-&gt;data</span></span><br><span class="line"><span class="comment">        c.单链表插入结点操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatListHead</span><span class="params">(LinkList *L,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkList p;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    *L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">    (*L)-&gt;next=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        p=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));</span><br><span class="line">        p-&gt;data=rand()%<span class="number">100</span>+<span class="number">1</span>;	<span class="comment">//1~100，rand()%100:0~99</span></span><br><span class="line">        p-&gt;next=(*L)-&gt;next;</span><br><span class="line">        (*L)-&gt;next=p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color: red;">尾插法</span>创建：<strong>先来后到，延长尾巴</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">尾插法创建思路：</span></span><br><span class="line"><span class="comment">    1.声明指针p，和指向表尾的指针r</span></span><br><span class="line"><span class="comment">    （初始化随机数发生器）</span></span><br><span class="line"><span class="comment">    2生成一个（暂时作为）尾结点</span></span><br><span class="line"><span class="comment">    3.循环生成结点，替代前一个尾结点作为新的尾结点</span></span><br><span class="line"><span class="comment">    	a.生成新尾结点赋值给p，生成随机数赋值给数据域p-&gt;data</span></span><br><span class="line"><span class="comment">    	b.p指针指向结点赋值给r-&gt;next：接在r后面</span></span><br><span class="line"><span class="comment">    	c.p赋值给r，r指针更新尾结点</span></span><br><span class="line"><span class="comment">    4.生成结点结束，最终确定尾结点，指针域r-&gt;next赋空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatListTail</span><span class="params">(LinkList *L,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkList p,r;	<span class="comment">//1</span></span><br><span class="line">    <span class="type">int</span> i;	</span><br><span class="line">    srand(time(<span class="number">0</span>));</span><br><span class="line">    *L=(LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));	</span><br><span class="line">    r=*L;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n ; i++)	<span class="comment">//3</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = (Node *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Node));	<span class="comment">//3.a</span></span><br><span class="line">        p-&gt;data=rand()%<span class="number">100</span>+<span class="number">1</span>;	<span class="comment">//3.a</span></span><br><span class="line">        r-&gt;next=p;	<span class="comment">//3.b</span></span><br><span class="line">        r=p;	<span class="comment">//3.c</span></span><br><span class="line">    &#125;</span><br><span class="line">    r-&gt;next=<span class="literal">NULL</span>;	<span class="comment">//4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="单链表的整表删除"><a href="#单链表的整表删除" class="headerlink" title="单链表的整表删除"></a>单链表的整表删除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">删除算法思路：</span></span><br><span class="line"><span class="comment">    1.【皇帝-&gt;太子】声明指针p负责释放结点，【遗嘱】指针q负责索引下一个待释放的结点</span></span><br><span class="line"><span class="comment">    2.从第一个结点开始（头结点-&gt;next==第一个结点，赋值给p）</span></span><br><span class="line"><span class="comment">    3.循环释放操作</span></span><br><span class="line"><span class="comment">        a.先将下一个结点p-&gt;next赋值给索引指针q</span></span><br><span class="line"><span class="comment">        b.释放p结点【free()】</span></span><br><span class="line"><span class="comment">        c.q赋值给p，继续下一个循环释放</span></span><br><span class="line"><span class="comment">    4.只剩下头结点，循环释放结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">ClearList</span><span class="params">(LinkList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkList p,q;	<span class="comment">//1</span></span><br><span class="line">    p=(*L)-&gt;next;	<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">while</span>(p)	<span class="comment">//3.循环释放</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=p-&gt;next;	<span class="comment">//3.a</span></span><br><span class="line">        <span class="built_in">free</span>(p);	<span class="comment">//3.b</span></span><br><span class="line">        p=q;	<span class="comment">//3.c</span></span><br><span class="line">    &#125;</span><br><span class="line">    (*L)-&gt;next=<span class="literal">NULL</span>;	<span class="comment">//4</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="静态链表【游标实现法】"><a href="#静态链表【游标实现法】" class="headerlink" title="静态链表【游标实现法】"></a>静态链表【游标实现法】</h4><ol>
<li><p><span style="color: red;">建立数组</span>描述的单链表： 每一个下标对应data（存放数据元素）、cur（存放后继的游标 &#x3D;&#x3D; next）</p>
<ol>
<li>备用链表：未被使用的空闲空间</li>
<li>特殊元素：头&amp;尾<ol>
<li>【≈索引指针】<strong>数组第一个元素</strong>cur存放备用链表第一个结点的下标</li>
<li>【≈头结点】<strong>数组最后一个元素</strong>cur存放第一个数值元素的下标（空链表：cur &#x3D;&#x3D; 0）</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*创建静态链表*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 1000	<span class="comment">//定义容量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="type">int</span> cur;</span><br><span class="line">&#125;Component,StaticLinkList[MAXSIZE];</span><br></pre></td></tr></table></figure>
</li>
<li><p>**<span style="color: red;">初始化</span>**数组状态：生成一个空链</p>
<ol>
<li>第i结点指针域（i-&gt;next）：space[i].cur</li>
<li>头指针：space[0].cur</li>
<li>空指针：“0”</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitList</span><span class="params">(StaticLinkList space)</span>	<span class="comment">//int InitList()&#123;&#125;</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;MAXSIZE<span class="number">-1</span>;i++)	<span class="comment">//下标i == n-1</span></span><br><span class="line">    &#123;</span><br><span class="line">        space[i].cur = i+<span class="number">1</span>;	<span class="comment">//第i个元素的cur指向i+1 (i-&gt;next = i+1;)</span></span><br><span class="line">    &#125;</span><br><span class="line">    space[MAXSIZE<span class="number">-1</span>].cur = <span class="number">0</span>;	<span class="comment">//空链：头结点的next为空</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现<strong>Malloc函数</strong>动态扩容：<span style="color: red;">查找当前</span>第一个新<span style="color: red;">待插入空节点</span>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">扩容：查找当前备用链表第一个空变量：</span></span><br><span class="line"><span class="comment">    1.初始第一个空闲节点（第一个内存空间的cur）赋值给i</span></span><br><span class="line"><span class="comment">    2.循环遍历：当第一个结点的cur不为空</span></span><br><span class="line"><span class="comment">        a.下一个结点作为新的第一个空闲节点，实现扩容+1</span></span><br><span class="line"><span class="comment">    3.返回i</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Malloc_SSL</span><span class="params">(StaticLinkList space)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = space[<span class="number">0</span>].cur;	<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span>(space[<span class="number">0</span>].cur)	<span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">        space[<span class="number">0</span>].cur = space[i].cur;	<span class="comment">//2.a</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;	<span class="comment">//3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color: red;">插入</span>操作：<strong>只</strong>需<strong>改变数组两个cur</strong>值（偷天换日）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">k：查找原i的cur</span></span><br><span class="line"><span class="comment">i：待插入到的位数</span></span><br><span class="line"><span class="comment">j：新产生的数据下标</span></span><br><span class="line"><span class="comment">插入：交换cur</span></span><br><span class="line"><span class="comment">    1.声明记录变量j、k、l，k从最大容量最后一位下标开始计算</span></span><br><span class="line"><span class="comment">    2.异常检测</span></span><br><span class="line"><span class="comment">    3.新节点下标赋值给j</span></span><br><span class="line"><span class="comment">    4.判断j是否为空（空间剩余）</span></span><br><span class="line"><span class="comment">        (1)e赋值数据域</span></span><br><span class="line"><span class="comment">        (2)循环遍历到第i个元素（遍历到原i-1位置）</span></span><br><span class="line"><span class="comment">            a.L[k].cur指向原i结点（即k为i-1结点位置）</span></span><br><span class="line"><span class="comment">        (3)改变cur实现插入1：新元素cur（L[j].cur）指向原i结点（L[k].cur）</span></span><br><span class="line"><span class="comment">        (4)改变cur实现插入2：原i-1结点的cur（L[k].cur）指向新节点（j）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">ListInsert</span><span class="params">(StaticLinkList L,<span class="type">int</span> i,ElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j,k,l;</span><br><span class="line">    k=MAXSIZE - <span class="number">1</span>;	<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span>(i &lt; <span class="number">1</span> || i &gt; ListLength(L) + <span class="number">1</span>)	<span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    j=Malloc_SSL(L);	<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">if</span>(j)	<span class="comment">//4</span></span><br><span class="line">    &#123;</span><br><span class="line">        L[j].data = e;	<span class="comment">//4(1)</span></span><br><span class="line">        <span class="keyword">for</span>(l = <span class="number">1</span>;l &lt;= i<span class="number">-1</span>;l++)	<span class="comment">//4(2)</span></span><br><span class="line">        &#123;</span><br><span class="line">            k = L[k].cur;	<span class="comment">//4(2).a</span></span><br><span class="line">        &#125;</span><br><span class="line">        L[i].cur=L[k].cur;	<span class="comment">//4（3）</span></span><br><span class="line">        L[k].cur=j;	<span class="comment">//4（4）</span></span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>实现<strong>free内存释放</strong>函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">已删除结点成为新的第一空闲结点（space[0].cur）</span></span><br><span class="line"><span class="comment">    1.已删除结点的cur指向原第一空闲结点</span></span><br><span class="line"><span class="comment">    2.k结点成为新的第一空闲元素，原space[0].cur成为第二空闲元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Free_SSL</span><span class="params">(StaticLinkList space,<span class="type">int</span> k)</span></span><br><span class="line">&#123;</span><br><span class="line">    space[k].cur = space[<span class="number">0</span>].cur;	<span class="comment">//1</span></span><br><span class="line">    space[<span class="number">0</span>].cur = k;	<span class="comment">//2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color: red;">删除</span>操作：确定需要释放的元素i，调用Free_SSL函数进行释放</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">确定需要释放的元素i：</span></span><br><span class="line"><span class="comment">    1.异常判断</span></span><br><span class="line"><span class="comment">    2.k从最大容量最后一位下标开始计算</span></span><br><span class="line"><span class="comment">    3.循环遍历到i-1位置</span></span><br><span class="line"><span class="comment">    4.将第i位结点赋值给j（L[j].cur）</span></span><br><span class="line"><span class="comment">    5.j的下一个结点作为新的第一个（有数据）结点</span></span><br><span class="line"><span class="comment">    6.调用赋值函数Free_SSL</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">ListDelete</span><span class="params">(StaticLinkList L,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j,k;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">1</span> || i&gt;ListLength(L))	<span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    k=MAXSIZE<span class="number">-1</span>;	<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>;j &lt;= i<span class="number">-1</span>;j++)	</span><br><span class="line">    &#123;</span><br><span class="line">        k= L[k].cur;	<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">    j = L[k].cur;	<span class="comment">//4</span></span><br><span class="line">    L[k].cur = L[j].cur;	<span class="comment">//5</span></span><br><span class="line">    Free_SSL(L,j);	<span class="comment">//6.传递k=j</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>遍历<span style="color: red;">检测静态链表长度</span>：返回<strong>数据元素个数</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">ListLength</span><span class="params">(StaticLinkList L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i=L[MAXSIZE<span class="number">-1</span>].cur;	<span class="comment">//最后元素的cur存放第一个（有数据）结点位置</span></span><br><span class="line">    <span class="keyword">while</span>(i)</span><br><span class="line">    &#123;</span><br><span class="line">        i=L[i].cur;	<span class="comment">//循环往后遍历，直到i为空</span></span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="循环链表：单链表尾接上头构成一个环"><a href="#循环链表：单链表尾接上头构成一个环" class="headerlink" title="循环链表：单链表尾接上头构成一个环"></a>循环链表：单链表尾接上头构成一个环</h4><ol>
<li><p><strong>空</strong>循环<strong>链</strong>：头指针head-&gt;next指向头指针head</p>
</li>
<li><p>（非空）循环链：<span style="color: green;">p-&gt;next !&#x3D; head</span>，则未到尾结点【头O(1)；<span style="color: blue;">尾O(n)</span>】</p>
</li>
<li><p>改造循环链：增加一个尾指针<span style="color: red;">rear</span>，第一个结点为<span style="color: red;">rear-&gt;next-&gt;next</span>【头O(1)；<span style="color: blue;">尾O(1)</span>】</p>
</li>
<li><p>链接两个带头结点的循环链表：都有头结点，只保留一个</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">p = rearA-&gt;next;</span><br><span class="line">rearA-&gt;next = rearB-&gt;next-&gt;next;</span><br><span class="line">q = rearB-&gt;next;</span><br><span class="line">rearB-&gt;next = p;</span><br><span class="line"><span class="built_in">free</span>(q);	<span class="comment">//释放B的头结点，只保留A头</span></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="双向链表：增加一个直接前驱指针prior的单链表"><a href="#双向链表：增加一个直接前驱指针prior的单链表" class="headerlink" title="双向链表：增加一个直接前驱指针prior的单链表"></a>双向链表：增加一个<span style="color: red;">直接前驱指针prior</span>的单链表</h4><ol>
<li><p>双向链表存储结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DulNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;DuLNode,*DuLinkList;	<span class="comment">//DuLNode是定义了一个双向循环链表,而*DuLinkList是定义了一个可以指向链表的指针(类型同链表)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>双向空循环</strong>链：头结点空链，rear，next两个指针都指向head</p>
</li>
<li><p><strong>双向非空循环</strong>链：前驱的后继（p-&gt;rear-&gt;next） &#x3D;&#x3D; 后继的前驱（p-&gt;next-&gt;rear） &#x3D;&#x3D; 自己（p）</p>
</li>
<li><p><span style="color: red;">插入</span>操作原则：改4个数据，注意顺序</p>
<ol>
<li><span style="color: purple;">&#x3D;&#x3D;先改新&#x3D;&#x3D;（待插入的结点），&#x3D;&#x3D;再改旧&#x3D;&#x3D;（原来前后结点指针域）</span></li>
<li><span style="color: purple;">&#x3D;&#x3D;先改后&#x3D;&#x3D;（后继next），&#x3D;&#x3D;再改前&#x3D;&#x3D;（前驱rear）</span></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;prior = p;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line">p-&gt;next = s;</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color: red;">删除</span>操作：改2个数据，顺序可交换</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;prior-&gt;next = p-&gt;next;	<span class="comment">//切断p前一个结点的next</span></span><br><span class="line">p-&gt;next-&gt;prior = p-&gt;prior;	<span class="comment">//切断p后一个结点的prior</span></span><br><span class="line"><span class="built_in">free</span>(p);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="四、栈与队列"><a href="#四、栈与队列" class="headerlink" title="四、栈与队列"></a>四、栈与队列</h1><ol>
<li><h3 id="栈（LIFO结构）"><a href="#栈（LIFO结构）" class="headerlink" title="栈（LIFO结构）"></a>栈（LIFO结构）</h3><ol>
<li><h4 id="定义：仅在表尾（栈顶top）插入-amp-删除的后进先出-x3D-x3D-线性表-x3D-x3D"><a href="#定义：仅在表尾（栈顶top）插入-amp-删除的后进先出-x3D-x3D-线性表-x3D-x3D" class="headerlink" title="定义：仅在表尾（栈顶top）插入&amp;删除的后进先出&#x3D;&#x3D;线性表&#x3D;&#x3D;"></a>定义：仅在<strong>表尾</strong>（栈顶top）插入&amp;删除的后进先出&#x3D;&#x3D;线性表&#x3D;&#x3D;</h4><ol>
<li>特点：线性表（栈元素具有线性关系，即前驱后继关系）、有栈顶top和栈底bottom、空栈</li>
<li>入（压）栈、出（弹）栈</li>
<li>进出栈变化形式：有位置限制，无时间限制</li>
<li>栈抽象数据类型（Stack）：类似线性表（P78~P79）</li>
</ol>
</li>
<li><h4 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h4><ol>
<li><p>空栈：<code>top = -1；</code>【数组元素从0开始】</p>
</li>
<li><p>top：栈顶指针</p>
</li>
<li><p>StackSize：栈长度</p>
</li>
<li><p>top &lt; StackSize</p>
</li>
<li><p>栈结构定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> SElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE];	<span class="comment">//存放数据的数组</span></span><br><span class="line">    <span class="type">int</span> top;	<span class="comment">//初始化栈顶指针，一般为 int top=-1；</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进栈操作Push</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 判断栈满</span></span><br><span class="line"><span class="comment">2. top++</span></span><br><span class="line"><span class="comment">3. 数据赋值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqStack *S,SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top == MAXSIZE <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;	<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    S-&gt;top++;	<span class="comment">//2</span></span><br><span class="line">    S-&gt;data[S-&gt;top]=e;	<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出栈操作Pop</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 判断栈空</span></span><br><span class="line"><span class="comment">2. 取出栈顶元素e</span></span><br><span class="line"><span class="comment">3. 栈顶top--</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqStack *S,SElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;	<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    *e=S-&gt;data[S-&gt;top];	<span class="comment">//2</span></span><br><span class="line">    S-&gt;top--;	<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">return</span> OK;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>共享栈（&#x3D;&#x3D;管道对接&#x3D;&#x3D;）【节约空间】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">共享栈空间结构定义：</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> top1,top2;</span><br><span class="line">&#125;SqDoubleStack;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">入栈Push：</span></span><br><span class="line"><span class="comment"> ++top1</span></span><br><span class="line"><span class="comment"> --top2</span></span><br><span class="line"><span class="comment"> 1. 判断栈满：top1 + 1==top2</span></span><br><span class="line"><span class="comment"> 2. 记录元素stackNumber判断 top1++ 或 top2--</span></span><br><span class="line"><span class="comment"> 3. 元素赋值 S-&gt;data[ ++S-&gt;top1 || --S-&gt;top2 ]=e；</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(SqDoubleStack *S,SElemType e,<span class="type">int</span> stackNumber)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(S-&gt;top1+<span class="number">1</span> == S-&gt;top2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(StackNumber == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;data[++S-&gt;top1] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        S-&gt;data[--S-&gt;top2] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">(栈顶元素)出栈Pop：</span></span><br><span class="line"><span class="comment">    top1--</span></span><br><span class="line"><span class="comment">    top2++</span></span><br><span class="line"><span class="comment">    1.记录元素stackNumber判断top1或top2</span></span><br><span class="line"><span class="comment">    2.异常判断栈空：</span></span><br><span class="line"><span class="comment">        top1 == -1</span></span><br><span class="line"><span class="comment">        top2 == MAXSIZE</span></span><br><span class="line"><span class="comment">    3.取出栈顶元素*e=S-&gt;data[S-&gt;top1-- || S-&gt;top2++]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(SqDoubleStack *S,SElemType *e,<span class="type">int</span> stackNumber)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(stackNumber == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S-&gt;top1==<span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ERROR;	<span class="comment">//栈1空，异常</span></span><br><span class="line">        &#125;*e=S-&gt;data[S-&gt;top1--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(stackNumber ==<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S-&gt;top2==MAXSIZE)</span><br><span class="line">        &#123;</span><br><span class="line">            ERROR;	<span class="comment">//栈2空，异常</span></span><br><span class="line">        &#125;*e=S-&gt;data[S-&gt;top2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>堆栈溢出：缺乏栈满判断，持续入栈，超出MAXSIZE</p>
</li>
</ol>
</li>
<li><h4 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h4><ol>
<li><p>特点：链栈不需要头结点（头指针和栈顶指针合二为一），由内存提供动态空间，不存在溢出问题，只存在系统崩溃死机问题</p>
</li>
<li><p>链栈结构定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定义数据结点，由data+next组成</span></span><br><span class="line"><span class="comment">定义top指针，计数元素count</span></span><br><span class="line"><span class="comment">空链栈：top == NULL 时</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType data;	<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span>	<span class="comment">//后继</span></span><br><span class="line">&#125;StackNode,*LinkStackPtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    LinkStackPtr top;</span><br><span class="line">    <span class="type">int</span> count;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链栈进栈操作：动态生成结点s，赋值元素e，s-&gt;next指向当前top指针指向的结点；top指向新结点s作为新栈顶；计数++</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 动态申请内存空间生成链栈结点</span></span><br><span class="line"><span class="comment">2. 数据域赋值</span></span><br><span class="line"><span class="comment">3. next指向当前栈顶指针top指向的结点</span></span><br><span class="line"><span class="comment">4. 成为新栈顶</span></span><br><span class="line"><span class="comment">5. 链栈count++</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">Push</span><span class="params">(LinkStack *S,SElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkStackPtr s=(LinkStackPtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(StackNode));	<span class="comment">//动态生成结点</span></span><br><span class="line">    s-&gt;data=e;</span><br><span class="line">    s-&gt;next=S-&gt;top;</span><br><span class="line">    S-&gt;top=s;</span><br><span class="line">    S-&gt;count++;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链栈出栈操作：取出栈顶结点给变量p，指针下移，释放p</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.生成指针变量p</span></span><br><span class="line"><span class="comment">2.异常判断，栈S是否存在</span></span><br><span class="line"><span class="comment">3.取出栈顶top的数据域data</span></span><br><span class="line"><span class="comment">4.p指向top结点</span></span><br><span class="line"><span class="comment">5.top的下移一位作为新top结点</span></span><br><span class="line"><span class="comment">6.释放p指向的结点原top</span></span><br><span class="line"><span class="comment">7.计数count--</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">Pop</span><span class="params">(LinkStack *S,SElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkStackPtr p;	<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span>(StackEmpty(*S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;	<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    *e=S-&gt;top-&gt;data;	<span class="comment">//3</span></span><br><span class="line">    p=S-&gt;top;	<span class="comment">//4</span></span><br><span class="line">    S-&gt;top=S-&gt;top-&gt;next;	<span class="comment">//5</span></span><br><span class="line">    <span class="built_in">free</span>(p);	<span class="comment">//6</span></span><br><span class="line">    S-&gt;count--;	<span class="comment">//7</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h4><ol>
<li>递归<ol>
<li>定义：把自己当函数调用（递归：选择结构；迭代：循环结构）（弊端：频繁调用函数，占内存）</li>
<li>(递归)栈操作：递归调用阶段 –&gt; 压&#x2F;入栈；递归回退阶段 –&gt; 弹&#x2F;出栈</li>
<li><span style="color: green;">实例：斐波那契数列（P86~88）</span></li>
</ol>
</li>
<li>四则运算表达式求值（中缀+后缀）<ol>
<li>括号成对出现，（遇左括号）左括号进栈，（遇右括号）将左括号出栈</li>
<li>中缀表达式转后缀：栈用来进出运算的&#x3D;&#x3D;符号&#x3D;&#x3D;</li>
<li>后缀表达式进行计算：栈用来进出运算的&#x3D;&#x3D;数字&#x3D;&#x3D;</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="队列（FIFO）"><a href="#队列（FIFO）" class="headerlink" title="队列（FIFO）"></a>队列（FIFO）</h3><ol>
<li><h4 id="定义：只允许在一段插入另一端删除的-先进先出-x3D-x3D-排队-x3D-x3D-线性表"><a href="#定义：只允许在一段插入另一端删除的-先进先出-x3D-x3D-排队-x3D-x3D-线性表" class="headerlink" title="定义：只允许在一段插入另一端删除的 先进先出 &#x3D;&#x3D;排队&#x3D;&#x3D; 线性表"></a>定义：只允许在一段插入另一端删除的 先进先出 &#x3D;&#x3D;排队&#x3D;&#x3D; 线性表</h4><ol>
<li>抽象数据类型（Queue）：P94~95</li>
</ol>
</li>
<li><h4 id="顺序队列-x3D-x3D-gt-循环队列（头尾相接的改进版顺序队，解决”假溢出“）"><a href="#顺序队列-x3D-x3D-gt-循环队列（头尾相接的改进版顺序队，解决”假溢出“）" class="headerlink" title="顺序队列 &#x3D;&#x3D;&gt; 循环队列（头尾相接的改进版顺序队，解决”假溢出“）"></a>顺序队列 &#x3D;&#x3D;&gt; 循环队列（头尾相接的改进版顺序队，解决”假溢出“）</h4><ol>
<li>队头指针：front</li>
<li>队尾指针：rear</li>
<li>队列最大尺寸：QueueSize</li>
<li>假溢出：数组中前端下标空闲，往后入队超出数组长度，非正常溢出，称为“假溢出”</li>
<li>循环队列两种判断队空队满方法<ol>
<li>方法一：设置<strong>标志变量flag</strong>，front &#x3D;&#x3D; rear，且flag&#x3D;0时，队空；front &#x3D;&#x3D; rear，且flag&#x3D;&#x3D;1，队满</li>
<li>方法二：<strong>保留一个元素空间</strong>，front &#x3D;&#x3D; rear，队空；数组中剩余一个空闲单位，即条件为：<code>(rear+1)%QueueSize == front</code>，队满<ol>
<li><p>队列长度：<span style="color: red;">(rear - front + QueueSize)%QueueSize</span> （通用长度计算公式）</p>
<ol>
<li>当rear &gt; front：rear-front</li>
<li>当rear &lt; front：rear-front+QueueSize</li>
</ol>
</li>
<li><p>循环队列顺序存储<strong>结构定义</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data[MAXSIZE];	<span class="comment">//数组存放</span></span><br><span class="line">    <span class="type">int</span> front;	<span class="comment">//队头指针</span></span><br><span class="line">    <span class="type">int</span> rear;	<span class="comment">//队尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化（建立）<strong>空队</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitQueue</span><span class="params">(SqQueue *Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    Q-&gt;front = <span class="number">0</span>;</span><br><span class="line">    Q-&gt;rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回队列长度：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">QueueLength</span><span class="params">(SqQueue Q)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (Q.rear-&gt;Q.front+MAXSIZE)%MAXSIZE;	<span class="comment">//循环队通用长度计算公式</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>入队：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 判断队满</span></span><br><span class="line"><span class="comment">2. 元素e赋值给队尾rear数据域data（排队）</span></span><br><span class="line"><span class="comment">3. 队尾rear后移一位，若最后一位转到头部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(SqQueue *Q,QElemType e)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXSIZE == Q.front)	<span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;data[Q-&gt;rear] = e;	<span class="comment">//2</span></span><br><span class="line">        Q-&gt;rear = (Q-&gt;rear+<span class="number">1</span>)%MAXSIZE;	<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>出队:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 判断队空</span></span><br><span class="line"><span class="comment">2. 取出队头front指针数据域赋值给*e</span></span><br><span class="line"><span class="comment">3. 队头front后移，若最后一位则转到头部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(SqQueue *Q,QElemType *e)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(Q-&gt;front == Q-&gt;rear)	<span class="comment">//1</span></span><br><span class="line">   &#123;</span><br><span class="line">   	*e = Q-&gt;data[Q-&gt;front];	<span class="comment">//2</span></span><br><span class="line">   	Q-&gt;front = Q-&gt;front+<span class="number">1</span>%MAXSIZE;	<span class="comment">//3</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="链队（尾进头出的单链表）"><a href="#链队（尾进头出的单链表）" class="headerlink" title="链队（尾进头出的单链表）"></a>链队（<span style="color: red;">尾进头出</span>的单链表）</h4><ol>
<li><p>空链队：front、rear 均指向<strong>头结点（含有）</strong></p>
</li>
<li><p>链队列结构建立：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> QElemType;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">结点结构建立：</span></span><br><span class="line"><span class="comment">    存放数据变量、next指针域</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>	<span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">队列链表结构建立：</span></span><br><span class="line"><span class="comment">    队头、队尾指针定义</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front, rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链队（队尾）入队：<span style="color: proplue;">变动尾指针rear</span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 动态生成新结点s</span></span><br><span class="line"><span class="comment">2. 异常判断：动态生成是否成功，内存溢出</span></span><br><span class="line"><span class="comment">3. 数据e赋值给结点s的数据域</span></span><br><span class="line"><span class="comment">4. 结点s指针域尾NULL，作为队尾</span></span><br><span class="line"><span class="comment">5. （原）尾指针rear指向的结点next指向（新结点）s</span></span><br><span class="line"><span class="comment">6. 尾指针rear指向新结点s</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">EnQueue</span><span class="params">(LinkQueue *Q,<span class="type">int</span> e)</span></span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr s = (QueuePtr)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));	<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span>(!s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>(OVERFLOW);	<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    s-&gt;data = e;	<span class="comment">//3</span></span><br><span class="line">    s-&gt;next = <span class="literal">NULL</span>:	<span class="comment">//4</span></span><br><span class="line">    Q-&gt;rear-&gt;next = s;	<span class="comment">//5</span></span><br><span class="line">    Q-&gt;rear = s;	<span class="comment">//6</span></span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>链队（队头）出队：<span style="color: proplue;">变动头指针front</span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 生成新指针变量p用于存放待删除结点</span></span><br><span class="line"><span class="comment">2. 异常检测：判断队空</span></span><br><span class="line"><span class="comment">3，队头结点（头指针的指针域next指向的结点）暂存到p</span></span><br><span class="line"><span class="comment">4. 取出暂存结点的数据域到*e</span></span><br><span class="line"><span class="comment">5. 此结点的指针域next指向的下一个结点 赋值给 头指针的指针域指向的结点，成为新的队头结点</span></span><br><span class="line"><span class="comment">6. 判断此结点是否为队尾（即原队列只存在一个数据），则将尾指针初始化空队（指向头结点）</span></span><br><span class="line"><span class="comment">7. 释放暂存结点p</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">DeQueue</span><span class="params">(LinkQueue *Q,<span class="type">int</span> *e)</span></span><br><span class="line">&#123;</span><br><span class="line">    QueuePtr p;	<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == Q-&gt;front)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;	<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    p = Q-&gt;front-&gt;next;	<span class="comment">//3</span></span><br><span class="line">    *e = p-&gt;data;	<span class="comment">//4</span></span><br><span class="line">    Q-&gt;front-&gt;next = p-&gt;next;	<span class="comment">//5</span></span><br><span class="line">    <span class="keyword">if</span>(Q-&gt;rear == p)</span><br><span class="line">    &#123;</span><br><span class="line">        Q-&gt;rear = Q-&gt;front;	<span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="五、串"><a href="#五、串" class="headerlink" title="五、串"></a>五、串</h1><ol>
<li><h3 id="字符串的定义：由-x3D-x3D-零个-x3D-x3D-或-x3D-x3D-多个-x3D-x3D-字符组成的-x3D-x3D-有限序列-x3D-x3D-（记作：s-x3D-“a1-a2-…-an”-n≥0-）"><a href="#字符串的定义：由-x3D-x3D-零个-x3D-x3D-或-x3D-x3D-多个-x3D-x3D-字符组成的-x3D-x3D-有限序列-x3D-x3D-（记作：s-x3D-“a1-a2-…-an”-n≥0-）" class="headerlink" title="字符串的定义：由&#x3D;&#x3D;零个&#x3D;&#x3D;或&#x3D;&#x3D;多个&#x3D;&#x3D;字符组成的&#x3D;&#x3D;有限序列&#x3D;&#x3D;（记作：s&#x3D;“a1 a2 … an”(n≥0)）"></a>字符串的定义：由&#x3D;&#x3D;零个&#x3D;&#x3D;或&#x3D;&#x3D;多个&#x3D;&#x3D;字符组成的&#x3D;&#x3D;有限序列&#x3D;&#x3D;（记作：s&#x3D;“a<sub>1</sub> a<sub>2</sub> … a<sub>n</sub>”(n≥0)）</h3><ol>
<li>空串（null string）：零个字符（n为串的长度）</li>
<li>空格串：只含有（多个）空格</li>
<li>子串、主串：包含子串的串称主串</li>
<li>串的抽象数据类型：P107</li>
</ol>
</li>
<li><h3 id="串的比较：逐位比较"><a href="#串的比较：逐位比较" class="headerlink" title="串的比较：逐位比较"></a>串的比较：<span style="color: red;">逐位</span>比较</h3><ol>
<li>标准ASCII码：128（7位二进制组成）</li>
<li>扩展ASCII码：256（8位二进制组成）</li>
<li>Unicode码：2<sup>16</sup>（16位二进制组成 ≈ 6.5w）【前256位跟ASCII码相同】</li>
</ol>
</li>
<li><h3 id="串的存储结构"><a href="#串的存储结构" class="headerlink" title="串的存储结构"></a>串的存储结构</h3><ol>
<li>顺序存储结构：用一组&#x3D;&#x3D;地址连续&#x3D;&#x3D;的存储单元来存储串中的字符序列【定长数组】<ol>
<li>a[0]：数组第一位保存预定义最大串长度</li>
<li>“\0”：串值终结（遍历长度：<code>for(i ; a[i] != &#39;\0&#39; ; i++)</code>）</li>
<li>弊端：超出数组长度Maxsize，发生上溢出，截尾</li>
<li>动态分配：由自由存储区“&#x3D;&#x3D;堆&#x3D;&#x3D;”调用C语言的malloc()、free()，进行动态分配管理</li>
</ol>
</li>
<li>链式存储结构：一个结点对应一个字符或多个字符，“#”补全（方便连接串，存储性能不如顺序结构）</li>
</ol>
</li>
<li><h3 id="串的模式匹配算法（子串的定位）"><a href="#串的模式匹配算法（子串的定位）" class="headerlink" title="串的模式匹配算法（子串的定位）"></a>串的模式匹配算法<span style="color: red;">（子串的定位）</span></h3><ol>
<li><p>朴素的模式匹配算法（主串（大循环）、子串（小循环）的循环遍历，比较指针回溯）【等概率原则：O(n+m)】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">T[0]、S[0]：存放串长度</span></span><br><span class="line"><span class="comment">1. 定义索引主串的指针i、索引子串的指针j=1（从头开始）</span></span><br><span class="line"><span class="comment">2. 判断：当主串指针小于等于主串长度 且 子串指针小于等于子串长度</span></span><br><span class="line"><span class="comment">    1. 判断：数据相等</span></span><br><span class="line"><span class="comment">        a. 主串指针、子串指针++</span></span><br><span class="line"><span class="comment">    2. 数据不等</span></span><br><span class="line"><span class="comment">        a.主串指针退回上次匹配首位的下一位</span></span><br><span class="line"><span class="comment">        b.子串指针重置 1</span></span><br><span class="line"><span class="comment">3. 判断：子串指针超出自串长度</span></span><br><span class="line"><span class="comment">        遍历完成，返回位置</span></span><br><span class="line"><span class="comment">4. 无结果，返回0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index</span><span class="params">(String S,String T,<span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=pos;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;	<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>] &amp;&amp; j&lt;=T[<span class="number">0</span>])	<span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(S[i]==T[j])	<span class="comment">//2.1</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//2.2</span></span><br><span class="line">        &#123;</span><br><span class="line">            i = i-j+<span class="number">2</span>;	<span class="comment">//2.a</span></span><br><span class="line">            j=<span class="number">1</span>;	<span class="comment">//2.b</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i-T[<span class="number">0</span>];	<span class="comment">//3</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><ins>KMP</ins>模式匹配算法（时间复杂度O(n+m)）</p>
<ol>
<li><p>最长模式串：前缀模式串 &#x3D;&#x3D; 后缀模式串（小于整个模式串长度）</p>
</li>
<li><p>增加next数组进行&#x3D;&#x3D;相似度查询&#x3D;&#x3D;：j值 的大小取决于<strong>当前字符之前的串前后缀的相似度</strong></p>
</li>
<li><p>next[j] 数组：存放最长重合前后缀长度+1</p>
</li>
<li><p>【第二位往后（k!&#x3D;0）】如果P<sub>j</sub> ≠ P<sub>next[j]</sub>，那么next[j+1]可能的<strong>次大值</strong>为next[ next[ j ] ]+1，以此类推知道值为1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">生成T串的next[]数组：</span></span><br><span class="line"><span class="comment">    1. 定义子串索引变量i=1 (T(0)存放串长度)，最长前缀表索引变量k=0</span></span><br><span class="line"><span class="comment">    2. next[1]数组首位为0</span></span><br><span class="line"><span class="comment">    3. 判断：当前位置i小于串长度</span></span><br><span class="line"><span class="comment">        1. 判断：前缀k==0 或 前缀最后一位数据==最长前缀k数据</span></span><br><span class="line"><span class="comment">            a.++i,++k</span></span><br><span class="line"><span class="comment">            b.记录第i位最长前缀k</span></span><br><span class="line"><span class="comment">        2. 数据不一样，回溯前一位匹配的k值（当前最长前缀不匹配，回朔至次长前缀接着比较）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_next</span><span class="params">(String T,<span class="type">int</span> *next)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>,k=<span class="number">0</span>;	<span class="comment">//1</span></span><br><span class="line">    next[<span class="number">1</span>]=<span class="number">0</span>;	<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;T[<span class="number">0</span>])	<span class="comment">//3</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span> || T[i]=T[k])	<span class="comment">//3.1</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++k;	<span class="comment">//3.1.a</span></span><br><span class="line">            next[i]=k;	<span class="comment">//3.1.b</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            k=next[k];	<span class="comment">//3.2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>经验总结：前后缀模式串n个字符相等，k值为n+1</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 定义索引主串的i，索引子串j</span></span><br><span class="line"><span class="comment">2. 生成预加载next数组长度；</span></span><br><span class="line"><span class="comment">3. 调用函数get_next计算传入子串T的next数组</span></span><br><span class="line"><span class="comment">4.判断子主串小于等于串长</span></span><br><span class="line"><span class="comment">    1. 判断j==0 或 主串值==子串值</span></span><br><span class="line"><span class="comment">        a.索引指针++</span></span><br><span class="line"><span class="comment">    2. 子串索引j按照next数组退回到合适位置</span></span><br><span class="line"><span class="comment">5. 判断子串索引结束</span></span><br><span class="line"><span class="comment">    a.遍历完成，返回位置</span></span><br><span class="line"><span class="comment">6. 不匹配，返回0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Index_KMP</span><span class="params">(String S,String T,<span class="type">int</span> pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=pos;</span><br><span class="line">    <span class="type">int</span> j=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> next[MAXSIZE];	<span class="comment">//2</span></span><br><span class="line">    get_next(T,next);	<span class="comment">//3</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;=S[<span class="number">0</span>] &amp;&amp; j&lt;=T[<span class="number">0</span>])	<span class="comment">//4</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j==<span class="number">0</span> || S[i]==T[j])	<span class="comment">//4.1</span></span><br><span class="line">        &#123;</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j=next[j];		<span class="comment">//4.2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&gt;T[<span class="number">0</span>])	<span class="comment">//5</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> i-T[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//6</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>改进版KMP模式匹配算法（改良next[]数组）</p>
<ol>
<li>计算next数组值时，<ins>如果a位字符与它next值指向的b位字符相等</ins>，则<strong>该a位的nextval就指向b位的nextval</strong></li>
<li>如果不等，则<strong>该a位的nextval值就是它自己的next的值</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.定义子串索引变量i=1 (T(0)存放串长度)，最长前缀表索引变量k=0</span></span><br><span class="line"><span class="comment">2.nextval[1]数组首位为0</span></span><br><span class="line"><span class="comment">3.判断：子串当前索引i小于子串长度</span></span><br><span class="line"><span class="comment">    1.判断：前缀长度k==0 或 当前i位置数据==最长前缀k数据</span></span><br><span class="line"><span class="comment">        a.i++,k++</span></span><br><span class="line"><span class="comment">        b.判断：当前i位置数据 ！= 最长前缀k位置的数据</span></span><br><span class="line"><span class="comment">                当前k为此i位置的最长前缀，赋值给nextval数组</span></span><br><span class="line"><span class="comment">        c.当前位置数据 == 前缀k位置数据</span></span><br><span class="line"><span class="comment">                k位置的nextval值赋值给当前i位置nextval值</span></span><br><span class="line"><span class="comment">    2.数据不相等，或k != 0，（k值回朔）次长前缀值nextval[k]赋值给当前索引k</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">get_nextval</span><span class="params">(String T,<span class="type">int</span> *nextval)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;	<span class="comment">//1</span></span><br><span class="line">    nextval[<span class="number">1</span>]=<span class="number">0</span>;	<span class="comment">//2</span></span><br><span class="line">    <span class="keyword">while</span>(i&lt;T[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(k==<span class="number">0</span> || T[i]==T[k])</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++k;	<span class="comment">//3.1.a</span></span><br><span class="line">            <span class="keyword">if</span>(T[i]!=T[k])</span><br><span class="line">            &#123;</span><br><span class="line">                nextval[i]=k;	<span class="comment">//3.1.b</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                nextval[i]=nextval[k];	<span class="comment">//3.1.c</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            k=nextval[k];	<span class="comment">//3.2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h1 id="六、树"><a href="#六、树" class="headerlink" title="六、树"></a>六、树</h1><ol>
<li><h3 id="树的定义（一对多）"><a href="#树的定义（一对多）" class="headerlink" title="树的定义（一对多）"></a>树的定义（一对多）</h3><ol>
<li>树的结构定义：有且仅有一个特定的<span style="color: red;">根</span>（root）的结点，其余节点为互不相交的有限集合，即<span style="color: red;">子树</span>，n&#x3D;0为<span style="color: prouple;">空树</span></li>
<li>（结点的）度：结点拥有的子树个数 ； 树的度：树中的&#x3D;&#x3D;度的最大值&#x3D;&#x3D;</li>
<li>结点间的关系：孩子，双亲，兄弟，祖先，子孙</li>
<li>树的相关概念：层次，高度，深度，堂兄弟，森林，有序&#x2F;无序树</li>
<li>树的抽象数据类型：P130</li>
</ol>
</li>
<li><h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><ol>
<li><p>双亲表示法（改：+长子域 &#x3D;&#x3D; 方便找孩子、+右兄弟域 &#x3D;&#x3D;&gt; 方便找兄弟）【根结点无双亲：-1（双亲域）】</p>
<ol>
<li><p>结构：<img src="/:/e4c7d9e61077414abd8d91b6b1b03038" alt="b32a02266416134b39aff7d20707c6ad.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义（双亲表示法）结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> parent;</span><br><span class="line">&#125;PTNode;</span><br><span class="line"><span class="comment">//定义树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PTNode nodes[MAX_TREE_SIZE];	<span class="comment">//结点数组</span></span><br><span class="line">    <span class="type">int</span> r,n;	<span class="comment">//r记录根位置，n记录结点数</span></span><br><span class="line">&#125;PTree;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>孩子表示法（改：+双亲域 &#x3D;&#x3D; 双亲孩子表示法）</p>
<ol>
<li><p>结构1：多重链表表示法（结点长度统一，多个指针域指向孩子，空为^）<img src="/:/201eb0ebd1054d77b67c0bf7bb68a219" alt="EP8S3KLWZ@_}YJNE0$Z%X6A.png"><span style="color: green;">（浪费空间）</span></p>
</li>
<li><p>结构2：长度不统一，按需分配，degree记录度数。<img src="/:/a912a8e2fb0a41ea82a523edb3654d77" alt="4[YXP~V05$[E3)VC@C[$2A9.png"></p>
</li>
<li><p>（最佳）结构3：顺序线性表（一维数组存储）+单链表（子结点）![3N@@%{4B77&#96;AS15@G{1TZ6S.png](:&#x2F;f9ac07328a994c99a73c017c6e8ff2d0)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（单链表）孩子结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> child;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CTNode</span> *<span class="title">next</span>;</span> </span><br><span class="line">&#125;*ChildPtr;</span><br><span class="line"><span class="comment">//（一维数组）表头节点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    ChildPtr firstchild;</span><br><span class="line">&#125;CTBox;</span><br><span class="line"><span class="comment">//树结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    CTBox nodes[MAX_SIZE];	<span class="comment">//结点数组</span></span><br><span class="line">    <span class="type">int</span> r,n;</span><br><span class="line">&#125;CTree;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>孩子兄弟表示法（可以转换为&#x3D;&#x3D;二叉链表&#x3D;&#x3D;：右兄弟变左孩子）</p>
<ol>
<li><p>结构：<img src="/:/12227b00f7524939b85eb9666d068d01" alt="8R39OOU@ODY1NYR$~%L76HL.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">rightsib</span>;</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><h3 id="二叉树的定义-amp-特点"><a href="#二叉树的定义-amp-特点" class="headerlink" title="二叉树的定义&amp;特点"></a>二叉树的定义&amp;特点</h3><ol>
<li>结构定义：根 + 左、右子树</li>
<li>二叉树三个特点：最多只有两度、区分左右、单结点分左右</li>
<li>二叉树的五种基本形态：空二叉树、只有根、左斜树、右斜树、左右斜树</li>
<li>特殊二叉树：斜树<span style="color: blue;">【结点个数&#x3D;深度】</span>、满二叉树<span style="color: blue;">【有左有右】</span>、完全二叉树（同结点深度最小）<span style="color: blue;">【编号连续的有序结点】</span></li>
</ol>
</li>
<li><h3 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h3><ol>
<li>二叉性质：<ol>
<li>【单层结点数】第i层至多有2<sup>i-1</sup>个结点（i≥1）</li>
<li>【总结点数】深度为k至多有2<sup>k</sup>-1个结点（k≥1）</li>
<li>任何一棵二叉树T，终端结点数为n<sub>0</sub>，度为2的结点数为n<sub>2</sub>，则n<sub>0</sub>&#x3D;n<sub>2</sub>+1。</li>
</ol>
</li>
<li>完全二叉性质：<ol>
<li>n个结点完全二叉树的深度为⌊log⁡<sub>2</sub>n⌋+1<span style="color: green;">（⌊x⌋：小于x的最大整数）</span></li>
<li>n个节点的完全二叉树的结点按层序编号，对任一结点i（1≤i≤n）有：<ol>
<li>如果i&#x3D;1，结点i是二叉树的根，无双亲；i&gt;1，气双亲式结点⌊i&#x2F;2⌋</li>
<li>如果2i&gt;n，结点i无左孩子（结点i为叶子结点）；否则左孩子是结点2i</li>
<li>如果2i+1&gt;n，则结点i无右孩子；否则其右孩子是结点2i+1</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="二叉树存储结构"><a href="#二叉树存储结构" class="headerlink" title="二叉树存储结构"></a>二叉树存储结构</h3><ol>
<li><p>顺序存储结构：上至下，左到右</p>
</li>
<li><p>链式存储结构：二叉链表<img src="/:/9011115775a5472ca979c4d098888a58" alt="b0977392113afa533bdc24d733f28f58.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据域+左右孩子</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="二叉树的遍历（从根结点出发，按照不同次序，对每个结点进行访问）"><a href="#二叉树的遍历（从根结点出发，按照不同次序，对每个结点进行访问）" class="headerlink" title="二叉树的遍历（从根结点出发，按照不同次序，对每个结点进行访问）"></a>二叉树的遍历（从根结点出发，按照不同<span style="color: red;">次序</span>，对每个结点进行<span style="color: red;">访问</span>）</h3><ol>
<li><p>前序遍历：根、左、右</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历T二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PreOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,T-&gt;data);</span><br><span class="line">    PreOrderTraverse(T-&gt;lchild);</span><br><span class="line">    PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>中序遍历：左、根、右</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrderTraverse</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    InOrderTraverse(T-&gt;lchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,T-&gt;data);</span><br><span class="line">    InOrderTraverse(T-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>后序遍历：左、右、根</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PostOrderTraverse(BiTree T)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PostOrderTraverse(T-&gt;lchild);</span><br><span class="line">    PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,T-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>层序遍历：同层，左到右、上到下</p>
</li>
<li><p>推导确定一颗二叉树：</p>
<ol>
<li>能确定：前序 + 中序、中序 + 后序</li>
<li>不能确定：前序 + 后序</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="扩展二叉树的建立【经处理后的二叉树：虚结点“-”表示空NULL】"><a href="#扩展二叉树的建立【经处理后的二叉树：虚结点“-”表示空NULL】" class="headerlink" title="扩展二叉树的建立【经处理后的二叉树：虚结点“#”表示空NULL】"></a>扩展二叉树的建立<span style="color: red;">【经处理后的二叉树：虚结点“#”表示空NULL】</span></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//前序遍历建立一个扩展二叉树</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatBiTree</span><span class="params">(BiTree T)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>,&amp;ch);	<span class="comment">//输入要生成的二叉树结点，输入#作为结点</span></span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        *T=<span class="literal">NULL</span>;	<span class="comment">//遇到#，作为空节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));	<span class="comment">//动态生成结点</span></span><br><span class="line">        <span class="keyword">if</span>(!*T)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">exit</span>(OVERFLOW);	<span class="comment">//（内存分配失败）异常判断</span></span><br><span class="line">        &#125;</span><br><span class="line">        (*T)-&gt;data=ch;</span><br><span class="line">        CreatBiTree(&amp;(*T)-&gt;lchild);</span><br><span class="line">        CreatBiTree(&amp;(*T)-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="线索二叉树（加上标志域tag，进行切换-x3D-x3D-孩子-x3D-x3D-和-x3D-x3D-前后-x3D-x3D-的二叉树）"><a href="#线索二叉树（加上标志域tag，进行切换-x3D-x3D-孩子-x3D-x3D-和-x3D-x3D-前后-x3D-x3D-的二叉树）" class="headerlink" title="线索二叉树（加上标志域tag，进行切换&#x3D;&#x3D;孩子&#x3D;&#x3D;和&#x3D;&#x3D;前后&#x3D;&#x3D;的二叉树）"></a>线索二叉树（加上标志域tag，进行切换&#x3D;&#x3D;孩子&#x3D;&#x3D;和&#x3D;&#x3D;前后&#x3D;&#x3D;的二叉树）</h3><ol>
<li>结构：<img src="/:/19502c2d00c2401ab989f25afa933225" alt="2f934f0cd86823d6ee9c2101da90857e.png"></li>
<li>线索化：将二叉链表中的<strong>空指针</strong>改为指向前驱后继的<strong>线索</strong>（对二叉树&#x3D;&#x3D;以某种次序遍历(前&#x2F;中&#x2F;后)&#x3D;&#x3D;，使其&#x3D;&#x3D;变为线索二叉树&#x3D;&#x3D;）【线索化过程：修改空指针的过程】</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//线索二叉树结点结构</span></span><br><span class="line"><span class="comment">//link = 0;thread = 1</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">enum</span> &#123;</span>Link,Tread&#125; PointerTag;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>	<span class="comment">//左右指针域</span></span><br><span class="line">    PointerTag LTag,RTag;	<span class="comment">//左右标志域</span></span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中序遍历线索化</span></span><br><span class="line"><span class="comment">//pre：临时存放上一个结点（用于作前驱）；p：用来索引结点</span></span><br><span class="line">BitThrTree pre;	<span class="comment">//全局变量，指向刚刚访问过的结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InThreading</span><span class="params">(BiThrTree p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(p)	<span class="comment">//树p存在</span></span><br><span class="line">    &#123;</span><br><span class="line">        InThreading(p-&gt;lchild);	<span class="comment">//左</span></span><br><span class="line">        <span class="comment">/*******线索化过程*********/</span></span><br><span class="line">        <span class="keyword">if</span>(!p-&gt;lchild)</span><br><span class="line">        &#123;</span><br><span class="line">            p-&gt;LTag=Thread;</span><br><span class="line">            p-&gt;lchild=pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!pre-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            pre-&gt;RTag=Thread;</span><br><span class="line">            pre-&gt;rchild=p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/****************************/</span></span><br><span class="line">        pre=p;	<span class="comment">//pre指向旧p</span></span><br><span class="line">        InThreading(p-&gt;rchild);	<span class="comment">//右</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="树、森林、二叉树的转换"><a href="#树、森林、二叉树的转换" class="headerlink" title="树、森林、二叉树的转换"></a>树、森林、二叉树的转换</h3><ol>
<li><h4 id="树-转换为-二叉树（转换方式：二叉链表）【右兄变右孩子】"><a href="#树-转换为-二叉树（转换方式：二叉链表）【右兄变右孩子】" class="headerlink" title="树 转换为 二叉树（转换方式：二叉链表）【右兄变右孩子】"></a>树 转换为 二叉树（转换方式：二叉链表）【右兄变右孩子】</h4></li>
<li><h4 id="森林-转换为-二叉树：1、-x3D-x3D-每棵树-x3D-x3D-转成二叉树。2、后一棵树-x3D-x3D-根结点-x3D-x3D-作为-x3D-x3D-前一个根的右孩子-x3D-x3D-。"><a href="#森林-转换为-二叉树：1、-x3D-x3D-每棵树-x3D-x3D-转成二叉树。2、后一棵树-x3D-x3D-根结点-x3D-x3D-作为-x3D-x3D-前一个根的右孩子-x3D-x3D-。" class="headerlink" title="森林 转换为 二叉树：1、&#x3D;&#x3D;每棵树&#x3D;&#x3D;转成二叉树。2、后一棵树&#x3D;&#x3D;根结点&#x3D;&#x3D;作为&#x3D;&#x3D;前一个根的右孩子&#x3D;&#x3D;。"></a>森林 转换为 二叉树：<strong>1、&#x3D;&#x3D;每棵树&#x3D;&#x3D;转成二叉树。2、后一棵树&#x3D;&#x3D;根结点&#x3D;&#x3D;作为&#x3D;&#x3D;前一个根的右孩子&#x3D;&#x3D;。</strong></h4></li>
<li><h4 id="二叉树-转换-树：（转换方式：逆二叉链表）【右孩子变右兄】"><a href="#二叉树-转换-树：（转换方式：逆二叉链表）【右孩子变右兄】" class="headerlink" title="二叉树 转换 树：（转换方式：逆二叉链表）【右孩子变右兄】"></a>二叉树 转换 树：（转换方式：逆二叉链表）【右孩子变右兄】</h4></li>
<li><h4 id="二叉树-转换-森林：1、-x3D-x3D-判断-x3D-x3D-：根有无右孩子。2、从根开始，-x3D-x3D-遇右-x3D-x3D-孩子-x3D-x3D-断开-x3D-x3D"><a href="#二叉树-转换-森林：1、-x3D-x3D-判断-x3D-x3D-：根有无右孩子。2、从根开始，-x3D-x3D-遇右-x3D-x3D-孩子-x3D-x3D-断开-x3D-x3D" class="headerlink" title="二叉树 转换 森林：1、&#x3D;&#x3D;判断&#x3D;&#x3D;：根有无右孩子。2、从根开始，&#x3D;&#x3D;遇右&#x3D;&#x3D;孩子&#x3D;&#x3D;断开&#x3D;&#x3D;"></a>二叉树 转换 森林：1、&#x3D;&#x3D;判断&#x3D;&#x3D;：根有无右孩子。2、从根开始，&#x3D;&#x3D;遇右&#x3D;&#x3D;孩子&#x3D;&#x3D;断开&#x3D;&#x3D;</h4></li>
<li><h4 id="森林的遍历：先根，后根；树的遍历：前序，后序"><a href="#森林的遍历：先根，后根；树的遍历：前序，后序" class="headerlink" title="森林的遍历：先根，后根；树的遍历：前序，后序"></a>森林的遍历：先根，后根；树的遍历：前序，后序</h4></li>
</ol>
</li>
<li><h3 id="哈夫曼树（最优二叉树）"><a href="#哈夫曼树（最优二叉树）" class="headerlink" title="哈夫曼树（最优二叉树）"></a>哈夫曼树（最优二叉树）</h3><ol>
<li><h4 id="哈夫曼树概念："><a href="#哈夫曼树概念：" class="headerlink" title="哈夫曼树概念："></a>哈夫曼树概念：</h4><ol>
<li>权：边上的数</li>
<li>路径长度：边的数目</li>
<li>带权路径长度：路长 * 结点上的权</li>
<li>【WPL】树的带权路径长度：所有结点带权路长之和（WPL<sub>min</sub> &#x3D;&#x3D; 哈夫曼树）</li>
</ol>
</li>
<li><h4 id="哈夫曼树生成方式："><a href="#哈夫曼树生成方式：" class="headerlink" title="哈夫曼树生成方式："></a>哈夫曼树生成方式：</h4><ol>
<li>&#x3D;&#x3D;从小到大&#x3D;&#x3D;排列带权的叶结点</li>
<li>选出&#x3D;&#x3D;两个最小结点&#x3D;&#x3D;，&#x3D;&#x3D;小左大右&#x3D;&#x3D;，&#x3D;&#x3D;相加作为新结点权值&#x3D;&#x3D;</li>
<li>加入新结点，&#x3D;&#x3D;重复操作&#x3D;&#x3D;</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="哈夫曼树的应用：哈夫曼编码方式（无损压缩、数据传输优化）"><a href="#哈夫曼树的应用：哈夫曼编码方式（无损压缩、数据传输优化）" class="headerlink" title="哈夫曼树的应用：哈夫曼编码方式（无损压缩、数据传输优化）"></a>哈夫曼树的应用：<span style="color: green;">哈夫曼编码</span>方式（无损压缩、数据传输优化）</h3><ol>
<li><strong>叶结点（源码）</strong>：{d<sub>1</sub>,d<sub>2</sub>,……,d<sub>n-1</sub>,d<sub>n</sub>}</li>
<li><strong>叶结点权值（各个字符出现的频率）</strong>：{w<sub>1</sub>,w<sub>2</sub>,……,w<sub>n-1</sub>,w<sub>n</sub>}</li>
<li><strong>左0右1</strong>：小左大右构成树</li>
<li><strong>哈夫曼编码</strong>：根结点 到 叶结点路径01序列</li>
</ol>
</li>
</ol>
<h1 id="七、图（概念多，算法较为复杂）"><a href="#七、图（概念多，算法较为复杂）" class="headerlink" title="七、图（概念多，算法较为复杂）"></a>七、图<span style="color: green;">（概念多，算法较为复杂）</span></h1><ol>
<li><h3 id="图的定义与术语"><a href="#图的定义与术语" class="headerlink" title="图的定义与术语"></a>图的定义与术语</h3><ol>
<li><h4 id="按方向区分："><a href="#按方向区分：" class="headerlink" title="按方向区分："></a>按方向区分：</h4><ol>
<li>有向图（顶点+弧 [弧头弧尾] ）<ol>
<li>邻接：入度+出度</li>
<li>强连通图：顶点间存在路径</li>
<li>有向树：一个入度为0，其余出度为1</li>
<li>生成森林：若干棵有向树</li>
</ol>
</li>
<li>无向图（顶点+边）<ol>
<li>邻接：度</li>
<li>连通图：存在路径</li>
<li>生成树：连通 + n个顶点 + n-1条边</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="环：首尾同顶点"><a href="#环：首尾同顶点" class="headerlink" title="环：首尾同顶点"></a>环：首尾同顶点</h4></li>
<li><h4 id="网（带权图）：边-x2F-弧上带权"><a href="#网（带权图）：边-x2F-弧上带权" class="headerlink" title="网（带权图）：边&#x2F;弧上带权"></a>网（带权图）：边&#x2F;弧上带权</h4></li>
<li><h4 id="按边-x2F-弧的数量区分（路径长度）：稀疏图、稠密图"><a href="#按边-x2F-弧的数量区分（路径长度）：稀疏图、稠密图" class="headerlink" title="按边&#x2F;弧的数量区分（路径长度）：稀疏图、稠密图"></a>按边&#x2F;弧的数量区分（路径长度）：稀疏图、稠密图</h4></li>
</ol>
</li>
<li><h3 id="图的五种存储结构"><a href="#图的五种存储结构" class="headerlink" title="图的五种存储结构"></a>图的五种存储结构</h3><ol>
<li><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><ol>
<li><p>结构定义：</p>
<ol>
<li>一维数组：保存 &#x3D;&#x3D;顶点&#x3D;&#x3D; 的信息<img src="/:/59ac077e33064c97825a43aa3360e668" alt="07f3958e30fe07daecbe316e89067733.png"></li>
<li>二维数组：保存 &#x3D;&#x3D;边&#x2F;弧&#x3D;&#x3D; 的信息（<strong>行出列入</strong>）<img src="/:/1e74f49b8bb945599d2a0b6966680bde" alt="6de1d4fa0606cafa73f3539c5aba0672.png"><img src="/:/954001c15b7b4a65bcde489065147259" alt="7b3005c33fad80edbc38fe31a301d09d.png"></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> INFINITY 65535;	<span class="comment">//∞</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">char</span> vexs[MAXSIZE];	<span class="comment">//一维数组（顶点表）</span></span><br><span class="line">    <span class="type">int</span> arc[MAXVEV][MAXVEX];	<span class="comment">//二维数组（邻接矩阵）</span></span><br><span class="line">    <span class="type">int</span> numNodes,numEdges;	<span class="comment">//记录当前顶点数，边数</span></span><br><span class="line">&#125;MGraph;</span><br></pre></td></tr></table></figure>
</li>
<li><p>邻接矩阵作用：</p>
<ol>
<li>判断邻接：根据邻接矩阵获取邻接点信息</li>
<li>求度：v<sub>i</sub>在第i行（或i列）的元素之和</li>
<li>求邻接：循环遍历第i行元素，arc[i][j] &#x3D;&#x3D; 1为邻接点</li>
</ol>
</li>
<li><p>网的邻接矩阵：邻接点多加一个权值W<sub>ij</sub>，自身为0（对角线），其他为∞</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.输入顶点数、边数</span></span><br><span class="line"><span class="comment">2.按顶点数循环：输入顶点</span></span><br><span class="line"><span class="comment">3.初始化邻接矩阵：双层循环结构遍历行/列，全部元素置为∞</span></span><br><span class="line"><span class="comment">4.按边数循环：</span></span><br><span class="line"><span class="comment">    (1)输入依附的顶点i，j，权值w</span></span><br><span class="line"><span class="comment">    (2)权值赋值到邻接矩阵对应i，j位置</span></span><br><span class="line"><span class="comment">    (3)按照邻接矩阵对角线对称性：i行j 列赋值 j行i列</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CreatMGraph</span><span class="params">(MGraph *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k,w;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数、边数：&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(%d %d,&amp;G-&gt;numNodes,&amp;G-&gt;numEdges);	<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span> ; i&lt;G-&gt;numNodes ; i++)	<span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入顶点信息存入顶点表：&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(&amp;G-&gt;vexs[i]);	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G-&gt;numNodes;i++)	<span class="comment">//双层循环：初始化</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G-&gt;numNodes;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            G-&gt;arc[i][j]=INFINITY;	<span class="comment">//3</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span> ; k&lt;G-&gt;numEdges ; k++ )	<span class="comment">//4</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入边(Vi,Vj)依附的顶点i，顶点j，权值w&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(%d %d %d,&amp;i,&amp;j,&amp;w)	<span class="comment">//4.1</span></span><br><span class="line">        G-&gt;arc[i][j] = w;	<span class="comment">//4.2</span></span><br><span class="line">        G-&gt;arc[j][i] = G-&gt;arc[i][j];	<span class="comment">//4.3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="邻接表（数组-链表）"><a href="#邻接表（数组-链表）" class="headerlink" title="邻接表（数组+链表）"></a>邻接表（数组+链表）</h4><ol>
<li><p>结构定义：</p>
<ol>
<li>一维数组：&#x3D;&#x3D;顶点&#x3D;&#x3D;（data） + &#x3D;&#x3D;指向第一个邻接点的指针&#x3D;&#x3D;（firstedge）<img src="/:/ef9898702ba94e60bb41afd59c31c0b6" alt="c6c354b6d996953f35bd9f8fe4598137.png"></li>
<li>线性链表：&#x3D;&#x3D;所有邻接点&#x3D;&#x3D;构成【无向图：边表】；&#x3D;&#x3D;以顶点为弧尾&#x3D;&#x3D;的上一个顶点构成【有向图：出边表】；（逆邻接表）&#x3D;&#x3D;以顶点为弧头&#x3D;&#x3D;的上一个顶点构成【有向图：入边表】<img src="/:/597993cc6a8348688519c0fc94bc198c" alt="26dc22c9ca63c5ad92e92fb8c53dae23.png"></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//（单链）结点结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex;	<span class="comment">//点域</span></span><br><span class="line">    <span class="type">char</span> info;	<span class="comment">//权</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span>	<span class="comment">//指针域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一维数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertextNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    VertexType data;	<span class="comment">//数据域</span></span><br><span class="line">    EdgeNode *firstedge;	<span class="comment">//表头指针域</span></span><br><span class="line">&#125;VertextNode,AdjList[MAXSIZE];</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList adjList;	</span><br><span class="line">    <span class="type">int</span> numNodes,numEdges;	<span class="comment">//边数&amp;顶点数</span></span><br><span class="line">&#125;GraphAdjList;</span><br></pre></td></tr></table></figure>
</li>
<li><p>无向图邻接表创建：O(n+e)</p>
<ol>
<li>创建初始化顶点表</li>
<li>头插法建立边表：生成单链表</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateALGraph</span><span class="params">(GraphAdjList *G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    EdgeNode *e;</span><br><span class="line">    <span class="comment">//建立初始化顶点表 |data|firstedge=NULL|</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入顶点数和边数：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d,%d&quot;</span>,&amp;G-&gt;numNodes,&amp;G-&gt;numEdges);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; G-&gt;numNodes ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(&amp;G-&gt;adjList[i].data);</span><br><span class="line">        G-&gt;adjList[i].firstedge=<span class="literal">NULL</span>;	<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//头插法建边表 |adjvex|(weight)|next|</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G&lt;numEdges;k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;输入边（Vi，Vj）上的顶点序号：\n&quot;</span>);</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d %d&quot;</span>,&amp;i,&amp;j);</span><br><span class="line">        <span class="comment">/*************头插入左端i结点*************/</span></span><br><span class="line">        e=(EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">        e-&gt;adjvex = j;</span><br><span class="line">        e-&gt;next = G-&gt;adjList[i].firstedge;</span><br><span class="line">        G-&gt;adjList[i].firstedge = e;</span><br><span class="line">        <span class="comment">/*************头插右端j结点**************/</span></span><br><span class="line">        e=(EdgeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(EdgeNode));</span><br><span class="line">        e-&gt;adjvex = i;</span><br><span class="line">        e-&gt;next = G-&gt;adjList[j].firstedge;</span><br><span class="line">        G-&gt;adjList[j].firstedge = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="十字链表（较难理解）（邻接表-逆邻接表）"><a href="#十字链表（较难理解）（邻接表-逆邻接表）" class="headerlink" title="十字链表（较难理解）（邻接表+逆邻接表）"></a>十字链表<span style="color: green;">（较难理解）</span>（邻接表+逆邻接表）</h4><ol>
<li>一维数组：顶点 + 指向第一个头 + 指向第一个尾<img src="/:/01074f8cf82f4b2faffd8f92f5e68b9d" alt="ad50d095dd09f10c40c98ee7ef1ffc4f.png"></li>
<li>出入邻接表：（出边表） &#x3D;&#x3D; 弧尾在顶点的下标【tailvex】 + 弧尾相同的下一条边指针域【taillink】 +（入边表） &#x3D;&#x3D; 弧头在顶点的下标【headvex】 + 弧头相同的下一条边指针域【headlink】<img src="/:/f6227c7e52ba4ab5ad59538b202b37c8" alt="12842cfc32567faa3aafa002327dd489.png"></li>
</ol>
</li>
<li><h4 id="多重邻接表（无向图：方便对边操作的改进版邻接表）"><a href="#多重邻接表（无向图：方便对边操作的改进版邻接表）" class="headerlink" title="多重邻接表（无向图：方便对边操作的改进版邻接表）"></a>多重邻接表（无向图：方便对边操作的改进版邻接表）</h4><ol>
<li>一维数组：data + firstedge<img src="/:/d4c16c2eb9414002826eca688eb4cd3e" alt="09e6577321c68b2f09dc8041bfe2d156.png"></li>
<li>改进邻接链表：<img src="/:/2b4da38f2cca432b9d9e7064f0706236" alt="fc74ebce89ca72f756606a338b4fe5bc.png"><ol>
<li>ivex、jvex：某条边依附的两个顶点下标（ilink指向的结点的jvex 一定要和本身的ivex值相同）</li>
<li>ilink、jlink：依附于顶点i、j的下一条边</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="边集数组（两个一维数组）"><a href="#边集数组（两个一维数组）" class="headerlink" title="边集数组（两个一维数组）"></a>边集数组（两个一维数组）</h4><ol>
<li>顶点：data<img src="/:/c9c949ec8c8f40ee875e46949b91d922" alt="d2ec37abb5f4234c0f358569b0bf801f.png"></li>
<li>边：起点下标（begin）、终点下标（end）、权值（weight）<img src="/:/6041335fa2c249f3b8c776cd6dd13848" alt="8371986b643ae8b750d3f3dd781140fb.png"></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> begin;</span><br><span class="line">    <span class="type">int</span> end;</span><br><span class="line">    <span class="type">int</span> weight;</span><br><span class="line">&#125;Edge;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ol>
<li><p>深度优先遍历DFS（递归回溯：一条路到底，层层回退）</p>
<ol>
<li><p>邻接矩阵DFS</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//深度优先递归算法</span></span><br><span class="line">Boolean visited[MAXVEX];</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(MGraph G,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    visited[i] = TRUE;	<span class="comment">//TRUE:已访问</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,G.vexs[i]);</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;G.numVertexes;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(G.arc[i][j] == <span class="number">1</span> &amp;&amp; !visited[j])</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(G,j);	<span class="comment">//未访问结点递归调用DFS</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(MGraph G)</span></span><br><span class="line"><span class="comment">//初始化所有结点为未访问状态FALSE</span></span><br><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.numVertexes;i++)</span><br><span class="line">&#123;</span><br><span class="line">    visited[i]=FALSE;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//DFS遍历</span></span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;G.numVertexes;i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!visited[i])</span><br><span class="line">    &#123;</span><br><span class="line">        DFS(G,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>邻接表DFS</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphAdjList GL,<span class="type">int</span> i)</span></span><br><span class="line">&#123;</span><br><span class="line">    EdgeNode *p;</span><br><span class="line">    visited[i] = TRUE;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,GL-&gt;adjList[i].data);</span><br><span class="line">    p=GL-&gt;adjList[i].firstedge;</span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[p-&gt;adjvex])</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(GL,p-&gt;adjvex);</span><br><span class="line">        &#125;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFSTraverse</span><span class="params">(GraphAdjList GL)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;GL-&gt;numVertexes;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i]= FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;GL-&gt;numVertexes;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            DFS(GL,i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>广度优先遍历BFS（队列：遍历顶点邻接）</p>
<ol>
<li>邻接矩阵BFS</li>
<li>邻接表DFS</li>
</ol>
</li>
</ol>
</li>
<li><h3 id="图的应用"><a href="#图的应用" class="headerlink" title="图的应用"></a>图的应用</h3><ol>
<li><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ol>
<li><h5 id="普里姆算法prim：从一点出发，逐步找已知顶点依附的最小权值边"><a href="#普里姆算法prim：从一点出发，逐步找已知顶点依附的最小权值边" class="headerlink" title="普里姆算法prim：从一点出发，逐步找已知顶点依附的最小权值边"></a>普里姆算法prim：<strong>从一点出发</strong>，<strong>逐步</strong>找已知顶点依附的最小权值边</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MiniSpanTree_Prim</span><span class="params">(MGraph G)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> min,i,j,k;</span><br><span class="line">    <span class="type">int</span> adjvex[MAXSIZE];</span><br><span class="line">    <span class="type">int</span> lowcost[MAXSIZE];</span><br><span class="line">    lowcost[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    adjvex[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.numVertexes;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lowcost[i]=G.arc[<span class="number">0</span>][i];</span><br><span class="line">        adjvex[i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;G.numVertexes;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min=INFINITY;</span><br><span class="line">        j=<span class="number">1</span>;k=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;G.numVertexes)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lowcost[j]!=<span class="number">0</span> &amp;&amp; lowcost[j]&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                min=lowcost[j];</span><br><span class="line">                k=j;</span><br><span class="line">            &#125;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;(%d,%d)\n&quot;</span>,adjvex[k],k);</span><br><span class="line">        lowcost[k]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;G.numVertexes;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(lowcost[j]!=<span class="number">0</span> &amp;&amp; G.arc[k][j]&lt;lowcost[j])</span><br><span class="line">            &#123;</span><br><span class="line">                lowcost[j] = G.arc[k][j];</span><br><span class="line">                adjvex[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="克鲁斯卡尔算法kruskal：把图中最短边一个个挑出来（上帝-x2F-全局视角）"><a href="#克鲁斯卡尔算法kruskal：把图中最短边一个个挑出来（上帝-x2F-全局视角）" class="headerlink" title="克鲁斯卡尔算法kruskal：把图中最短边一个个挑出来（上帝&#x2F;全局视角）"></a>克鲁斯卡尔算法kruskal：把图中<strong>最短边</strong>一个个挑出来（上帝&#x2F;<strong>全局</strong>视角）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MiniSpanTree_Kruskal</span><span class="params">(MGraph G)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="最短路径（源点到终点权值之和最小的路径）"><a href="#最短路径（源点到终点权值之和最小的路径）" class="headerlink" title="最短路径（源点到终点权值之和最小的路径）"></a>最短路径（源点到终点权值之和最小的路径）</h4><ol>
<li><h5 id="迪杰斯特拉算法dijkstra（单源顶点查找）"><a href="#迪杰斯特拉算法dijkstra（单源顶点查找）" class="headerlink" title="迪杰斯特拉算法dijkstra（单源顶点查找）"></a>迪杰斯特拉算法dijkstra（单源顶点查找）</h5><ol>
<li><p>结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> vexs[MAXVEX];</span><br><span class="line">    <span class="type">int</span> arc[MAXVEX][MAXVEX];</span><br><span class="line">    <span class="type">int</span> numVertexes,numEdges;</span><br><span class="line">&#125;MGraph;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Patharc[MAXVEX];	<span class="comment">//存储存储最短路径下标的数组</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MAXVEX];	<span class="comment">//各点最短路径的权值和</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>dijkstra算法：</p>
<ol>
<li>P[]：该位顶点依附最短权的上一位顶点</li>
<li>D[]：V<sub>0</sub>到V<sub>该点</sub>的最短路径长度</li>
<li>final[]：标记数组。0为位置最短路长，1为已知最短路长</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShortestPath_Dijkstra</span><span class="params">(MGraph G,<span class="type">int</span> v0,Patharc *P,ShortPathTable *D)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w,k,min;</span><br><span class="line">    <span class="type">int</span> final[MAXVEX];</span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.numVertexes;v++)</span><br><span class="line">    &#123;</span><br><span class="line">        final[v]=<span class="number">0</span>;</span><br><span class="line">        (*D)[v]=G.arc[v0][v];</span><br><span class="line">        (*P)[v]=<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    (*D)[v0]=<span class="number">0</span>;</span><br><span class="line">    final[v0]=<span class="number">1</span>;</span><br><span class="line">    <span class="comment">/***********主循环，每次求得v0到某个顶点v的最短路径***************/</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">1</span>;v&lt;G.numVertexes;v++)</span><br><span class="line">    &#123;</span><br><span class="line">        min=INFINITY;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.numVertexes;w++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!final[w] &amp;&amp; (*D)[w]&lt;min)</span><br><span class="line">            &#123;</span><br><span class="line">                k=w;</span><br><span class="line">                min=(*D)[w];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        final[k]=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>;w&lt;G.numVertexes;w++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!final[w] &amp;&amp; (min+G.arc[k][w]&lt;(*D)[w]))</span><br><span class="line">            &#123;</span><br><span class="line">                (*D)[w]=min + G.arc[k][w];</span><br><span class="line">                (*P)[w]=k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="弗洛伊德算法floyd：（应用矩阵的变化）二重循环初始化-三重循环修正-【适合：求所有顶点到任意顶点】"><a href="#弗洛伊德算法floyd：（应用矩阵的变化）二重循环初始化-三重循环修正-【适合：求所有顶点到任意顶点】" class="headerlink" title="弗洛伊德算法floyd：（应用矩阵的变化）二重循环初始化 + 三重循环修正 【适合：求所有顶点到任意顶点】"></a>弗洛伊德算法floyd：（应用矩阵的变化）二重循环初始化 + 三重循环修正 【适合：求所有顶点到任意顶点】</h5><ol>
<li>二维数组：D<sup>-1</sup>（Data）：存放最短路径权值<span style="color: green;">（初始化：-1）</span></li>
<li>二维数组：P<sup>-1</sup>（Path）：存放路径信息<span style="color: green;">（初始化：-1）</span></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> Patharc[MAXVEX][MAXVEX];</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ShortPathTable[MAXVEX][MAXVEX];</span><br><span class="line"><span class="type">void</span> <span class="title function_">ShortPath_Floyd</span><span class="params">(MGraph G,Patharc *P,ShortPathTable *D)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> v,w,k;</span><br><span class="line">    <span class="comment">//二重循环初始化</span></span><br><span class="line">    <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.numVertexes;++v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(w=<span class="number">0</span>,w&lt;G.numVertexes;++w)</span><br><span class="line">        &#123;</span><br><span class="line">            (*D)[v][w]=G.arc[v][w];</span><br><span class="line">            (*P)[v][w]=w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//三重循环修正</span></span><br><span class="line">    <span class="keyword">for</span>(k=<span class="number">0</span>;k&lt;G.numVertexes;++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.numVertexes;++v)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(w=<span class="number">0</span>;k&lt;G.numVertexes;++w)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>((*D)[v][w]&gt;(*D)[v][k]+(*D)[k][w])</span><br><span class="line">                &#123;</span><br><span class="line">                    (*D)[v][w]=(*D)[v][k]+(*D)[k][w];</span><br><span class="line">                    (*P)[v][w]=(*P)[v][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="最短路径显示：遍历矩阵"><a href="#最短路径显示：遍历矩阵" class="headerlink" title="最短路径显示：遍历矩阵"></a>最短路径显示：遍历矩阵</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(v=<span class="number">0</span>;v&lt;G.numVertexes;++v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(w=v+<span class="number">1</span>;w&lt;G.numVertexes;w++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;v%d-v%d weight:%d&quot;</span>,v,w,D[v][w]);	<span class="comment">//遍历打印矩阵D</span></span><br><span class="line">        k=P[v][w];	<span class="comment">//k索引矩阵P</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;path:%d&quot;</span>,v);	<span class="comment">//打印源点</span></span><br><span class="line">        <span class="keyword">while</span>(k!=w)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;-&gt; %d&quot;</span>,k);	<span class="comment">//打印路径顶点</span></span><br><span class="line">            k=P[k][w];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;-&gt;%d\n&quot;</span>,w);	<span class="comment">//打印终点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="工程规划（有向无环图）"><a href="#工程规划（有向无环图）" class="headerlink" title="工程规划（有向无环图）"></a><span style="color: purple;">工程规划（有向无环图）</span></h4><ol>
<li><p>边表结构：<img src="/:/fe92f682b8fc447c8d6e490f004abbfc" alt="23a0c7143ed9873836d7d034cd74783d.png">（有向 + weight）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//边表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> adjvex;	<span class="comment">//邻接点域</span></span><br><span class="line">    <span class="type">int</span> weight;	<span class="comment">//权值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EdgeNode</span> *<span class="title">next</span>;</span>	<span class="comment">//下一个邻接点链域</span></span><br><span class="line">&#125;EdgeNode;</span><br></pre></td></tr></table></figure>
</li>
<li><p>顶点表结构：<img src="/:/119f262d857a41eaa4cc2beb0d071c1f" alt="a0232cf0f368f2a317f6aab1bed12da0.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点表结点</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VertexNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> in;	<span class="comment">//顶点入度</span></span><br><span class="line">    <span class="type">int</span> data;	<span class="comment">//顶点数据域</span></span><br><span class="line">    EdgeNode *firstedge;	<span class="comment">//边表头指针</span></span><br><span class="line">&#125;VertexNode,AdjList[MAXVEX];</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="拓扑排序（AOV网）"><a href="#拓扑排序（AOV网）" class="headerlink" title="拓扑排序（AOV网）"></a>拓扑排序（AOV网）</h5><ol>
<li><p>顶点：活动</p>
</li>
<li><p>弧：活动间的优先关系</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList adjList;</span><br><span class="line">    <span class="type">int</span> numVertexes,numEdges;	<span class="comment">//记录顶点数、边数</span></span><br><span class="line">&#125;graphAdjList,*GraphAdjList;</span><br></pre></td></tr></table></figure>
</li>
<li><p>进行拓补排序的辅助数据结构：<strong>栈</strong>【用来存储处理过程中入度为0的顶点】</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n+e)</span></span><br><span class="line">Status <span class="title function_">ToplpgicalSort</span><span class="params">(GraphAdjList GL)</span></span><br><span class="line">&#123;</span><br><span class="line">    EdgeNode *e;</span><br><span class="line">    <span class="type">int</span> i,k,gettop;</span><br><span class="line">    <span class="type">int</span> top=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="built_in">stack</span>=(<span class="type">int</span> *)<span class="built_in">malloc</span>(GL-&gt;numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    fot(i=<span class="number">0</span>;i&lt;GL-&gt;numVertexes;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span>==GL-&gt;adjList[i].in)	<span class="comment">//入度为0顶点入栈</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">stack</span>[++top]=i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">while</span>(top!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gettop=<span class="built_in">stack</span>[top--];	<span class="comment">//弹栈，取除栈顶，top--</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d-&gt;&quot;</span>,GL-&gt;adjList[gettop].data);</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">for</span>(e=GL-&gt;adjList[gettop].firstedge ; e ; e=e-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            k=e-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(!(--GL-&gt;adjList[k].in))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">stack</span>[++top]=k</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count &lt; GL-&gt;numVertexes)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> OK;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="关键路径（AOE网）（带权有向图）"><a href="#关键路径（AOE网）（带权有向图）" class="headerlink" title="关键路径（AOE网）（带权有向图）"></a>关键路径（AOE网）<span style="color: green;">（带权有向图）</span></h5><ol>
<li>顶点 V<sub>k</sub>：事件【最早：etv ；最晚：ltv】</li>
<li>弧（有向边）a<sub>k</sub>：活动【最早：ete ； 最晚：lte】</li>
<li>弧上权值：活动持续时间</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *etv,*ltv;	<span class="comment">//（顶点）事件最早发生和最迟发生时间数组</span></span><br><span class="line"><span class="type">int</span> *stack2;	<span class="comment">//存储拓补序列的栈</span></span><br><span class="line"><span class="type">int</span> top2;	<span class="comment">//栈顶指针</span></span><br><span class="line"><span class="comment">/*********用stack2进行拓补排序************/</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//O(n+e)</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">CriticalPath</span><span class="params">(GraphAdjList GL)</span></span><br><span class="line">&#123;</span><br><span class="line">    EdgeNode *e;</span><br><span class="line">    <span class="type">int</span> i,gettop,k,j;</span><br><span class="line">    <span class="type">int</span> ete,lte;	<span class="comment">//（弧）活动最早发生时间，活动最迟发生时间</span></span><br><span class="line">    TopologicalSort(GL);</span><br><span class="line">    ltv=(<span class="type">int</span> *)<span class="built_in">malloc</span>(GL-&gt;numVertexes * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">//初始化ltv</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;GL-&gt;numVertexes;i++)</span><br><span class="line">    &#123;</span><br><span class="line">            ltv[i]=etv[GL-&gt;numVertexes<span class="number">-1</span>];	</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//计算事件最迟ltv</span></span><br><span class="line">    <span class="keyword">while</span>(top2!=<span class="number">0</span>)	</span><br><span class="line">    &#123;</span><br><span class="line">        gettop=stack2[top--];</span><br><span class="line">        <span class="keyword">for</span>(e=GL-&gt;adjList[gettop].firstedge;e;e=e-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            k=e-&gt;adjvex;</span><br><span class="line">            <span class="keyword">if</span>(ltv[k] - e-&gt;weight &lt; ltv[gettop])</span><br><span class="line">            &#123;</span><br><span class="line">                ltv[gettop] = ltv[k] - e-&gt;weight;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//求ete,lte,关键活动</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;GL-&gt;numVertexes;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(e=GL-&gt;adjList[j].firstedge; e ;e=e-&gt;next)</span><br><span class="line">        &#123;</span><br><span class="line">            k=e-&gt;adjvex;</span><br><span class="line">            ete=etv[j];</span><br><span class="line">            lte=ltv[k] - e-&gt;weight;	</span><br><span class="line">            <span class="keyword">if</span>(ete == lte)	<span class="comment">//活动最早最晚相等，意味活动中没有空闲时间，即关键路径</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;&lt;v%d - v%d&gt; length: %d \n&quot;</span>,GL-&gt;adjList[j],data,GL-&gt;adjList[k].data,e-&gt;weight);	<span class="comment">//打印关键路径</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="八、查找"><a href="#八、查找" class="headerlink" title="八、查找"></a>八、查找</h1><ol>
<li><h3 id="查找表：静态查找表-只查-、动态查找表-查、增、删"><a href="#查找表：静态查找表-只查-、动态查找表-查、增、删" class="headerlink" title="查找表：静态查找表[只查]、动态查找表[查、增、删]"></a>查找表：静态查找表[只查]、动态查找表[查、增、删]</h3></li>
<li><h3 id="关键字（key）：主关键字-amp-次关键字"><a href="#关键字（key）：主关键字-amp-次关键字" class="headerlink" title="关键字（key）：主关键字 &amp; 次关键字"></a>关键字（key）：主关键字 &amp; 次关键字</h3></li>
<li><h3 id="查找结构："><a href="#查找结构：" class="headerlink" title="查找结构："></a>查找结构：</h3><ol>
<li><h4 id="顺序表查找（也叫线性查找）（静态查找）"><a href="#顺序表查找（也叫线性查找）（静态查找）" class="headerlink" title="顺序表查找（也叫线性查找）（静态查找）"></a>顺序表查找（也叫线性查找）<span style="color: green;">（静态查找）</span></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历查找数组</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]==key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//优化线性表查找：添加哨兵key</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sequential_Search2</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    a[<span class="number">0</span>]=key;</span><br><span class="line">    i=n;</span><br><span class="line">    <span class="keyword">while</span>(a[i]!=key)</span><br><span class="line">    &#123;</span><br><span class="line">        i--;	<span class="comment">//倒序遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="有序表查找"><a href="#有序表查找" class="headerlink" title="有序表查找"></a>有序表查找</h4><ol>
<li><h5 id="折半（二分）查找法（O-logn-）"><a href="#折半（二分）查找法（O-logn-）" class="headerlink" title="折半（二分）查找法（O(logn)）"></a>折半（二分）查找法<span style="color: green;">（O(logn)）</span></h5><ol>
<li>前提1:线性表中记录必须是关键码有序（一般：小到大）</li>
<li>前提2:必须采用顺序存储</li>
<li>思路：for（取中间值，比大小）</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">循环（low&lt;=high）：</span></span><br><span class="line"><span class="comment">    1.折半</span></span><br><span class="line"><span class="comment">    2.判断：小左大右，</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Binary_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low,high,mid;</span><br><span class="line">    low=<span class="number">1</span>;</span><br><span class="line">    high=n;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;	<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span>(key&lt;a[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;a[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="插值查找法（折半查找改进版：mid-x3D-low-high-low-key-a-low-x2F-a-high-a-low-）"><a href="#插值查找法（折半查找改进版：mid-x3D-low-high-low-key-a-low-x2F-a-high-a-low-）" class="headerlink" title="插值查找法（折半查找改进版：mid &#x3D; low+(high-low) * ( (key-a[low]) &#x2F; (a[high]-a[low]) ）"></a>插值查找法（<span style="color: red;">折半查找改进版</span>：mid &#x3D; low+(high-low) * ( (key-a[low]) &#x2F; (a[high]-a[low]) ）</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Interpolation_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low,high,mid;</span><br><span class="line">    low=<span class="number">1</span>;</span><br><span class="line">    high=n;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=low+(high -low)*(key-a[low]) / (a[high] - a[low]);	<span class="comment">//折半算法改进==&gt;插值查找</span></span><br><span class="line">        <span class="keyword">if</span>(key&lt;a[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            high=mid <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;a[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            low=mid +<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h5 id="斐波那契查找法（mid-x3D-low-F-k-1-1）（黄金分割原理-n-x3D-0-n-x3D-1-n-gt-1）"><a href="#斐波那契查找法（mid-x3D-low-F-k-1-1）（黄金分割原理-n-x3D-0-n-x3D-1-n-gt-1）" class="headerlink" title="斐波那契查找法（mid&#x3D;low+F[k-1]-1）（黄金分割原理:n&#x3D;0,n&#x3D;1,n&gt;1）"></a>斐波那契查找法（mid&#x3D;low+F[k-1]-1）<span style="color: green;">（黄金分割原理:n&#x3D;0,n&#x3D;1,n&gt;1）</span></h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">F(n)= 0  |  1  |  F(n-1)+F(n-2)</span></span><br><span class="line"><span class="comment">1.key=a[mid],success</span></span><br><span class="line"><span class="comment">2.key&lt;a[mid]，新范围：第low到mid-1；范围个数：F[k-1]-1个</span></span><br><span class="line"><span class="comment">3.key&gt;a[mid]，新范围：第m+1个到high个；范围个数：F[k-2]-1个</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">Fibonacci_Search</span><span class="params">(<span class="type">int</span> *a,<span class="type">int</span> n,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> low,high,mid,i,k;</span><br><span class="line">    low=<span class="number">1</span>;</span><br><span class="line">    high=n;</span><br><span class="line">    k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; F[k]<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=n;i&lt;F[k]<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i]=a[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=low+F[k<span class="number">-1</span>]<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(key&lt;a[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            high=mid<span class="number">-1</span>;</span><br><span class="line">            k=k<span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&gt;a[mid])</span><br><span class="line">        &#123;</span><br><span class="line">            low=mid+<span class="number">1</span>;</span><br><span class="line">            k=k<span class="number">-2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(mid&lt;=n)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="线性-x3D-x3D-索引表-x3D-x3D-查找索引：1-线性索引（表）-2-树形索引-3-多级索引"><a href="#线性-x3D-x3D-索引表-x3D-x3D-查找索引：1-线性索引（表）-2-树形索引-3-多级索引" class="headerlink" title="线性&#x3D;&#x3D;索引表&#x3D;&#x3D;查找索引：1.线性索引（表） 2.树形索引 3.多级索引"></a>线性&#x3D;&#x3D;索引表&#x3D;&#x3D;查找<span style="color: blue;">索引：1.线性索引（表） 2.树形索引 3.多级索引</span></h4><ol>
<li>稠密索引：索引表存放数据关键码，<strong>每个记录对应索引项</strong></li>
<li>分块索引：按类（有序）分块，块内无序（最大关键码，块长，块首指针）</li>
<li>倒排索引：<span style="color: green;">（”搜索引擎“）</span>（通用结构：次关键码、记录号表[存储具有相同次关键字的所有记录的记录号]）</li>
</ol>
</li>
<li><h4 id="二叉排序树（二叉查找树）"><a href="#二叉排序树（二叉查找树）" class="headerlink" title="二叉排序树（二叉查找树）"></a>二叉排序树<span style="color: green;">（二叉查找树）</span></h4><ol>
<li><p>二叉排序树的性质：</p>
<ol>
<li>左子树上所有结点的值均小于它的根结点的值</li>
<li>右子树上所有结点的值均大于它的跟结点的值</li>
<li>左右子树均分别为二叉排序树</li>
</ol>
</li>
<li><p>查找操作</p>
<ol>
<li><p>二叉排序树结点结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typdef <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>查找算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.（遍历完成，无子树了）查找失败，返回Flase</span></span><br><span class="line"><span class="comment">2.（key==指针的data）查找成功，返回结点元素，返回True</span></span><br><span class="line"><span class="comment">3.（key&lt;指针的data）向左子递归</span></span><br><span class="line"><span class="comment">4.（key&gt;指针的data）向右子递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">SearchBST</span><span class="params">(BiTree T,<span class="type">int</span> key,BiTree f,BiTree *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)</span><br><span class="line">    &#123;</span><br><span class="line">        *p=f;</span><br><span class="line">        <span class="keyword">return</span> Flase;	<span class="comment">//1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key== T-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        *p=T;</span><br><span class="line">        <span class="keyword">return</span> True;	<span class="comment">//2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;T-&gt;data)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild,key,T,p);	<span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild,key,T,p);	<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>插入（+调用插入 构建二叉排序树）</p>
<ol>
<li><p>插入操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. if(查找结点失败)：</span></span><br><span class="line"><span class="comment">    1. 动态生成结点</span></span><br><span class="line"><span class="comment">    2. key元素赋值</span></span><br><span class="line"><span class="comment">    3. 生成左右子树赋值为空（初始化）</span></span><br><span class="line"><span class="comment">    4. if（空树）：s作新根结点</span></span><br><span class="line"><span class="comment">    5. elif（key小于p-&gt;data）：s赋值左子树</span></span><br><span class="line"><span class="comment">    6. elif（key大于p-&gt;data）：s赋值右子树</span></span><br><span class="line"><span class="comment">2. else（Flase）：树中已经有相同关键字结点，不再插入</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">InsertBST</span><span class="params">(BiTree *T,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree p,s;</span><br><span class="line">    <span class="keyword">if</span>(!SearchBST(*T,key,<span class="literal">NULL</span>,&amp;p))</span><br><span class="line">    &#123;</span><br><span class="line">        s=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        s-&gt;data = key;</span><br><span class="line">        s-&gt;lchild=s-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(!p)</span><br><span class="line">        &#123;</span><br><span class="line">            *T=s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用插入操作构建二叉排序树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span>  a[<span class="number">7</span>]=&#123;<span class="number">33</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">66</span>,<span class="number">77</span>,<span class="number">88</span>,<span class="number">99</span>&#125;;	<span class="comment">//排序元素</span></span><br><span class="line">BiTree T=<span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    InsertBST(&amp;T,a[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>删除操作</p>
<ol>
<li><p>删除操作三种情况（类型）：</p>
<ol>
<li>叶结点</li>
<li>仅有左&#x2F;右子树结点</li>
<li>有左有右子树结点</li>
</ol>
</li>
<li><p>查找并判断结点类型 -&gt; 调用删除结点</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. if(元素不存在)：False</span></span><br><span class="line"><span class="comment">2. else</span></span><br><span class="line"><span class="comment">   1. if：找到关键字key</span></span><br><span class="line"><span class="comment">   	调用Delete（）</span></span><br><span class="line"><span class="comment">   2. elif：小于关键字key</span></span><br><span class="line"><span class="comment">   	左递归</span></span><br><span class="line"><span class="comment">   3. elif：大于关键字key</span></span><br><span class="line"><span class="comment">   	右递归</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">DeleteBST</span><span class="params">(BiTree *T,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span>(!*T)</span><br><span class="line">   &#123;</span><br><span class="line">   	<span class="keyword">return</span> False;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">else</span></span><br><span class="line">   &#123;</span><br><span class="line">   	<span class="keyword">if</span>(key==(*T)-&gt;data)</span><br><span class="line">   	&#123;</span><br><span class="line">   		<span class="keyword">return</span> Delete(T);	<span class="comment">//1</span></span><br><span class="line">   	&#125;</span><br><span class="line">   	<span class="keyword">else</span> <span class="keyword">if</span>(key&lt;(*T)-&gt;data)</span><br><span class="line">   	&#123;</span><br><span class="line">   		<span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;lchild,key);	<span class="comment">//2</span></span><br><span class="line">   	&#125;</span><br><span class="line">   	<span class="keyword">else</span></span><br><span class="line">   	&#123;</span><br><span class="line">   		<span class="keyword">return</span> DeleteBST(&amp;(*T)-&gt;rchild,key);	<span class="comment">//3</span></span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除结点操作</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 只有左子树：接上左子树，释放</span></span><br><span class="line"><span class="comment">2. 只有右子树：接上右子树，释放</span></span><br><span class="line"><span class="comment">3. 有左有右：</span></span><br><span class="line"><span class="comment">    1. (while)循环遍历右子树直到叶结点，存放在s</span></span><br><span class="line"><span class="comment">    2. s转移覆盖（赋值）到被删结点位置</span></span><br><span class="line"><span class="comment">    3.与原被删结点的左孩子比较：</span></span><br><span class="line"><span class="comment">        a. 不等，s左孩子接为右</span></span><br><span class="line"><span class="comment">        b. 相等，s左孩子接为左</span></span><br><span class="line"><span class="comment">    4. 释放s</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">Delete</span><span class="params">(BiTree *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree q,s;</span><br><span class="line">    <span class="keyword">if</span>((*p)-&gt;rchild==<span class="literal">NULL</span>)	<span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=*p;</span><br><span class="line">        *p=(*p)-&gt;lchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((*p)-&gt;lchild==<span class="literal">NULL</span>))	<span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=*p;</span><br><span class="line">        *p=(*p)-&gt;rchild;</span><br><span class="line">        <span class="built_in">free</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//3</span></span><br><span class="line">    &#123;</span><br><span class="line">        q=*p;</span><br><span class="line">        s=(*p)-&gt;lchild;</span><br><span class="line">        <span class="keyword">while</span>(s-&gt;rchild)</span><br><span class="line">        &#123;</span><br><span class="line">            q=s;</span><br><span class="line">            s=s-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">        (*p)-&gt;data=s-&gt;data;</span><br><span class="line">        <span class="keyword">if</span>(q!=*p)</span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;rchild=s-&gt;lchild;	<span class="comment">//3.a</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q-&gt;lchild=s-&gt;lchild;	<span class="comment">//3.b</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">free</span>(s);	<span class="comment">//4</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><h4 id="平衡二叉（排序）树"><a href="#平衡二叉（排序）树" class="headerlink" title="平衡二叉（排序）树"></a>平衡二叉（排序）树</h4><ol>
<li><p>BF(平衡因子)：左子树的高度 - 右子树的高度</p>
</li>
<li><p>构建平衡二叉树以稳定二叉排序树的性能：每个结点的左右子树高度差不超过1</p>
</li>
<li><p><strong>平衡二叉树构造思路：</strong></p>
<ol>
<li>最小不平横子树根结点的BF大于1，右旋</li>
<li>最小不平衡子树根结点的BF小于-1，左旋</li>
<li>最小不平衡子树符号相反：对结点先进行一次旋转后使得符号相同，再反响旋转构成平衡</li>
</ol>
</li>
<li><p>平衡二叉结点结构定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="type">int</span> bf;	<span class="comment">//平衡因子</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure>
</li>
<li><p>旋转操作函数</p>
<ol>
<li><p>右旋操作函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">R_Rotate</span><span class="params">(BiTree *P)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree L;</span><br><span class="line">    L=(*P)-&gt;lchild;</span><br><span class="line">    <span class="comment">//顺时针旋转</span></span><br><span class="line">    (*P)-&gt;lchild=L-&gt;rchild;</span><br><span class="line">    L-&gt;rchild=(*P);</span><br><span class="line">    *P=L;	<span class="comment">//新根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>左旋操作函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">L_Rotate</span><span class="params">(BiTree *P)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree R;</span><br><span class="line">    R=(*P)-&gt;rchild;</span><br><span class="line">    <span class="comment">//逆时针</span></span><br><span class="line">    (*P)-&gt;rchild=R-&gt;lchild;</span><br><span class="line">    R-&gt;lchild=(*P);</span><br><span class="line">    *P=R;	<span class="comment">//新根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>旋转处理函数：</p>
<ol>
<li><p>全局变量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> LH +1	<span class="comment">//左高</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> EH 0	<span class="comment">//等高</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> RH -1	<span class="comment">//右高</span></span></span><br></pre></td></tr></table></figure>
</li>
<li><p>右平衡旋转处理函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 右子树赋值为R</span></span><br><span class="line"><span class="comment">2. 判断：右子树的bf</span></span><br><span class="line"><span class="comment">    1. 新结点插入在右孩子上，作左旋处理</span></span><br><span class="line"><span class="comment">        a. 修改右子树bf值为等高</span></span><br><span class="line"><span class="comment">        b. 调用左旋操作</span></span><br><span class="line"><span class="comment">    2. 新结点插入在左孩子上，作双旋处理</span></span><br><span class="line"><span class="comment">        1. Rl指向左孩子</span></span><br><span class="line"><span class="comment">        2. 判断：左孩子的bf，进行bf值修改</span></span><br><span class="line"><span class="comment">            a. -1：右子树的bf改为左高；R指针bf改为等高</span></span><br><span class="line"><span class="comment">            b. 0：左子树和R指针bf都改为等高</span></span><br><span class="line"><span class="comment">            c. +1：左子树bf改为等高；R指针的bf改为右高</span></span><br><span class="line"><span class="comment">        3. 修改左孩子bf值为等高</span></span><br><span class="line"><span class="comment">        4. 右子树进行一次右旋操作</span></span><br><span class="line"><span class="comment">        5. 调用左旋操作</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">RightBalance</span><span class="params">(BiTree *T)</span></span><br><span class="line">&#123;</span><br><span class="line">    BiTree R,Rl;</span><br><span class="line">    R=(*T)-&gt;rchild;	<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">switch</span>(R-&gt;bf)	<span class="comment">//2.1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> RH:</span><br><span class="line">            (*T)-&gt;bf=R-&gt;bf=EH;	<span class="comment">//2.1.1.a</span></span><br><span class="line">            L_Rotate(T);	<span class="comment">//2.1.1.b</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> LH:	<span class="comment">//2.2</span></span><br><span class="line">            Rl=R-&gt;lchild;	<span class="comment">//2.2.1</span></span><br><span class="line">            <span class="keyword">switch</span>(Rl-&gt;bf)	<span class="comment">//2.2.2</span></span><br><span class="line">            &#123;</span><br><span class="line">                    <span class="keyword">case</span>:RH	<span class="comment">//2.2.a</span></span><br><span class="line">                        (*T)-&gt;bf=LH;</span><br><span class="line">                        R-&gt;bf= EH;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span>:EH	<span class="comment">//2.2.b</span></span><br><span class="line">                        (*T)-&gt;bf=R-&gt;bf=EH;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span>:LH	<span class="comment">//2.2.c</span></span><br><span class="line">                        (*T)-&gt;bf=EH;</span><br><span class="line">                        R-&gt;bf=RH;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Rl-&gt;bf=EH;	<span class="comment">//2.3</span></span><br><span class="line">            R_Rotate(&amp;(*T)-&gt;rchild);	<span class="comment">//2.4</span></span><br><span class="line">            L_Rotate(T);	<span class="comment">//2.5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>左平衡旋转处理函数：</p>
</li>
</ol>
</li>
<li><p>构建<strong>生成平衡二叉树</strong>主函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 树不存在，初始化生成空树</span></span><br><span class="line"><span class="comment">        定义taller指针进行保存树是否长高 TRUE &amp; FLASE</span></span><br><span class="line"><span class="comment">2.判断：插入元素数据与原树左子树比较</span></span><br><span class="line"><span class="comment">    1. 等于，树中已存在相同元素，返回Flase</span></span><br><span class="line"><span class="comment">    1. 小于，查找左子树</span></span><br><span class="line"><span class="comment">    2. 大于，查找右子树</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Status <span class="title function_">InsertAVL</span><span class="params">(BiTree *T,<span class="type">int</span> e,Status *taller)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!*T)	<span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">        *T=(BiTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BiTNode));</span><br><span class="line">        (*T)-&gt;data=e;</span><br><span class="line">        (*T)-&gt;lchild=(*T)-&gt;rchild=<span class="literal">NULL</span>;</span><br><span class="line">        (*T)-&gt;bf=EH;</span><br><span class="line">        *taller=TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//2</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(e==(*T)-&gt;data)	<span class="comment">//2.1</span></span><br><span class="line">        &#123;</span><br><span class="line">            *taller=FALSE;</span><br><span class="line">            <span class="keyword">return</span> FLASE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(e&lt;(*T)-&gt;data)	<span class="comment">//2.2(小左)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> FLASE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(*taller)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span>((*T)-&gt;bf)	<span class="comment">//检查平衡度</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> LH:</span><br><span class="line">                        LeftBalance(T);</span><br><span class="line">                        *taller=FLASE;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EH:</span><br><span class="line">                        (*T)-&gt;bf=LH;</span><br><span class="line">                        *taller=TRUE;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> RH:</span><br><span class="line">                        (*T)-&gt;bf=EH;</span><br><span class="line">                        *taller=FLASE;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>	<span class="comment">//2.3(大右)</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!InsertAVL(&amp;(*T)-&gt;lchild,e,taller))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> FLASE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(*taller)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span>((*T)-&gt;bf)	<span class="comment">//检查平衡度</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">case</span> LH:</span><br><span class="line">                        (*T)-&gt;bf=EH;</span><br><span class="line">                        *taller=FLASE;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> EH:</span><br><span class="line">                        (*T)-&gt;bf=RH;</span><br><span class="line">                        *taller=TRUE;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> RH:</span><br><span class="line">                        RightBalance(T);</span><br><span class="line">                        *taller=FLASE;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color: blue;"><span style="color: blue;">生成平衡二叉树函数调用方式：</span></span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> i;</span><br><span class="line"><span class="type">int</span> a[<span class="number">10</span>]=&#123;<span class="number">1</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">6</span>&#125;;</span><br><span class="line">BiTree T=<span class="literal">NULL</span>;</span><br><span class="line">Status taller;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">    InsertAVL(&amp;T,a[i],&amp;taller);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="多路查找树：-「原则：小左大右」"><a href="#多路查找树：-「原则：小左大右」" class="headerlink" title="多路查找树： 「原则：小左大右」"></a>多路查找树： <span style="color: red;">「原则：小左大右」</span></h4><ol>
<li><h5 id="B树（平衡的多路查找树）（为内外存交互的数据结构）"><a href="#B树（平衡的多路查找树）（为内外存交互的数据结构）" class="headerlink" title="B树（平衡的多路查找树）（为内外存交互的数据结构）"></a>B树（平衡的多路查找树）<span style="color: green;">（为内外存交互的数据结构）</span></h5><ol>
<li><p>B树的阶（order）：结点最大的孩子数目</p>
</li>
<li><h6 id="2-3树：（3阶B树）-x3D-x3D-gt-2树：1元素2孩子-x2F-NULL-；-3树：2元素3孩子-x2F-NULL"><a href="#2-3树：（3阶B树）-x3D-x3D-gt-2树：1元素2孩子-x2F-NULL-；-3树：2元素3孩子-x2F-NULL" class="headerlink" title="2-3树：（3阶B树） &#x3D;&#x3D;&gt; 2树：1元素2孩子&#x2F;NULL ； 3树：2元素3孩子&#x2F;NULL"></a>2-3树：（3阶B树） &#x3D;&#x3D;&gt; 2树：1元素2孩子&#x2F;NULL ； 3树：2元素3孩子&#x2F;NULL</h6></li>
<li><h6 id="2-3-4树：（4阶B树）-x3D-x3D-gt-3元素4孩子-x2F-NULL"><a href="#2-3-4树：（4阶B树）-x3D-x3D-gt-3元素4孩子-x2F-NULL" class="headerlink" title="2-3-4树：（4阶B树） &#x3D;&#x3D;&gt; 3元素4孩子&#x2F;NULL"></a>2-3-4树：（4阶B树） &#x3D;&#x3D;&gt; 3元素4孩子&#x2F;NULL</h6></li>
<li><h6 id="m阶B树"><a href="#m阶B树" class="headerlink" title="m阶B树"></a>m阶B树</h6></li>
</ol>
</li>
<li><h5 id="B-树：添加一个关键字索引（B树的变形树）（为文件系统所需的数据结构）"><a href="#B-树：添加一个关键字索引（B树的变形树）（为文件系统所需的数据结构）" class="headerlink" title="B+树：添加一个关键字索引（B树的变形树）（为文件系统所需的数据结构）"></a>B+树：添加一个关键字索引（B树的变形树）（<span style="color: green;">为文件系统所需的数据结构</span>）</h5><ol>
<li>n棵子树的结点包含n个关键字</li>
<li>所有叶子结点包含全部关键字信息，叶结点依关键字大小从小到大链接</li>
<li>分支结点看成索引</li>
</ol>
</li>
</ol>
</li>
<li><h4 id="散列表查找（空间换时间『最好O-1-』）：一个key（关键字）对应一个-f-key-（散列函数）"><a href="#散列表查找（空间换时间『最好O-1-』）：一个key（关键字）对应一个-f-key-（散列函数）" class="headerlink" title="散列表查找（空间换时间『最好O(1)』）：一个key（关键字）对应一个 f(key)（散列函数）"></a>散列表查找<span style="color: green;">（空间换时间『最好O(1)』）</span>：一个key<span style="color: blue;">（关键字）</span>对应一个 f<sub>(key)</sub><span style="color: blue;">（散列函数）</span></h4><ol>
<li>&#x3D;&#x3D;散列技术&#x3D;&#x3D;：面向查找的存储结构（存储方法+查找方法）</li>
<li>&#x3D;&#x3D;冲突&#x3D;&#x3D;：同义字（key1 !&#x3D; key2，f<sub>(key1)</sub> &#x3D;&#x3D; f<sub>(key2)</sub>）</li>
<li><h5 id="散列函数的构造方法："><a href="#散列函数的构造方法：" class="headerlink" title="散列函数的构造方法："></a>散列函数的构造方法：</h5><ol>
<li>直接定址法：取关键字的&#x3D;&#x3D;某个线性函数值&#x3D;&#x3D;为散列地址，即：f(key) &#x3D; a*key+b（a、b为常数）</li>
<li>数字分析法（抽取关键字）：”断章取义法“</li>
<li>平方取中法</li>
<li>折叠法：拆分-&gt;叠加求和-&gt;截取后几位</li>
<li>除留取余法：（可结合平方取中&#x2F;折叠法等）取余数，f(key) &#x3D; key <sub>mod</sub> p (p &lt;&#x3D; m)</li>
<li>随机数：f(key) &#x3D; random(key)<span style="color: blue;">（使用随机函数random()）</span></li>
</ol>
</li>
<li><h5 id="处理散列冲突："><a href="#处理散列冲突：" class="headerlink" title="处理散列冲突："></a>处理散列冲突：</h5><ol>
<li>开放定址法(线性探测法)：一旦发生冲突，就寻找下一个散列地址，f<sub>i</sub>(key) &#x3D; (f(key)+d<sub>i</sub>) MOD m(d<sub>i</sub>&#x3D;1,2,3,…,m-1)<ol>
<li>二次探测法：增加平方运算 f<sub>i</sub>(key)&#x3D;(f (key)+d<sub>i</sub>)MOD m(d<sub>i</sub>&#x3D;1<sup>2</sup>,2<sup>2</sup>,…,q<sup>2</sup>,-q<sup>2</sup>,q &lt;&#x3D; m&#x2F;2)</li>
<li>随机探测法：对位移量d<sub>i</sub>进行随机函数计算 f<sub>i</sub>(key)&#x3D;(f(key)+d<sub>i</sub>)MOD m(d<sub>i</sub>是一个随机数列)</li>
</ol>
</li>
<li>再散列函数：事先准备多个散列函数 f<sub>i</sub>(key)&#x3D;RH<sub>i</sub>(key)（i&#x3D;1,2,…,k）</li>
<li>链地址法：单链表存储同义词（同义词子表）『弊端：遍历单链表损耗一定性能』</li>
<li>公共溢出法：溢出表存放溢出同义关键字</li>
</ol>
</li>
<li><h5 id="散列表查找实现"><a href="#散列表查找实现" class="headerlink" title="散列表查找实现"></a>散列表查找实现</h5><ol>
<li><p>结点结构：动态数组</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> SUCCESS 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UNSUCCESS 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> HASHSIZE 12</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NULLKEY -32768</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> *elem;	<span class="comment">//数据元素存储基址</span></span><br><span class="line">    <span class="type">int</span> count;	<span class="comment">//记录当前数据元素个数</span></span><br><span class="line">&#125;HashTable;</span><br><span class="line"><span class="type">int</span> m=<span class="number">0</span>;	<span class="comment">//散列表长索引遍历</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化散列表</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">InitHashTable</span><span class="params">(HashTable *H)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    m=HASHSZIE;</span><br><span class="line">    H-&gt;count=m;</span><br><span class="line">    H-&gt;elem=(<span class="type">int</span> *)<span class="built_in">malloc</span>(m*<span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    <span class="comment">/*****循环赋空键初始化*****/</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        H-&gt;elem[i]=NULLKEY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>散列（处理）函数：除留取余</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Hash</span><span class="params">(<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> key % m;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>散列表插入关键字</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InserHash</span><span class="params">(HashTable *H,<span class="type">int</span> key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> addr = Hash(key);</span><br><span class="line">    <span class="keyword">while</span>(H-&gt;elem[addr]!=NULLKEY)</span><br><span class="line">    &#123;</span><br><span class="line">        addr = (addr+<span class="number">1</span>) % m;</span><br><span class="line">    &#125;</span><br><span class="line">    H-&gt;elem[addr] = key;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>关键字查找</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Status <span class="title function_">SearchHash</span><span class="params">(HashTable H,<span class="type">int</span> key,<span class="type">int</span> *addr)</span></span><br><span class="line">&#123;</span><br><span class="line">    *addr=Hash(key);</span><br><span class="line">    <span class="keyword">while</span>(H.elem[*addr] != key)</span><br><span class="line">    &#123;</span><br><span class="line">        *addr = (*addr+<span class="number">1</span>) %m;</span><br><span class="line">        <span class="keyword">if</span>(H.elem[*addr] ==NULLKEY || *addr == Hash(key))	<span class="comment">//循环回到原点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> UNSUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h1 id="九、排序"><a href="#九、排序" class="headerlink" title="九、排序"></a>九、排序</h1><ol>
<li><h3 id="排序基本概念："><a href="#排序基本概念：" class="headerlink" title="排序基本概念："></a>排序基本概念：</h3><ol>
<li>排序依据：按照关键字之间的大小关系</li>
<li>内排序：所有记录置放在内存中</li>
<li>外排序：内外存交换数据</li>
<li>性能影响因素：<ol>
<li>时间性能：比较 &amp; 移动</li>
<li>辅助空间：除了存放待排序所占用的存储空间外</li>
<li>按照复杂性区分：简单算法 &amp;&amp; 改进算法</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXSIZE 10000</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> r[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="type">int</span> length;</span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure>
</li>
<li><h3 id="简单算法类："><a href="#简单算法类：" class="headerlink" title="简单算法类："></a>简单算法类：</h3><ol>
<li><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h4><ol>
<li><p>机械性两两比较排序：两层循环进行两两相邻比较，反序交换，直到没有反序</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=L-&gt;length;j++)	</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L-&gt;r[i] &gt; L-&gt;r[j])</span><br><span class="line">            &#123;</span><br><span class="line">                swap(L,i,j);	<span class="comment">//调用swap交换L-&gt;r[i],L-&gt;r[j]的值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color: greed;">（正宗）</span>冒泡排序：从后往前循环比较，小数上浮</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.循环：从后往前</span></span><br><span class="line"><span class="comment">2.比较：前者大于后者</span></span><br><span class="line"><span class="comment">3.交换：前后交换</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;=L-&gt;length;i++)	<span class="comment">//1</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=length<span class="number">-1</span> ; j&gt;=i ; j--)	</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L-&gt;r[j] &gt; L-&gt;r[j+<span class="number">1</span>])	<span class="comment">//2</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(L,j,j+<span class="number">1</span>);	<span class="comment">//3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优化版冒泡排序：增加一个标记变量&#x3D;&#x3D;flag&#x3D;&#x3D;实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort2</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    Status flag=TRUE;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length &amp;&amp; flag==TRUE ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        flag=FALSE;	<span class="comment">//初始化flag值FLASE</span></span><br><span class="line">        <span class="keyword">for</span>(j=L-&gt;length<span class="number">-1</span> ; j&gt;=i ; j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L-&gt;r[j] &gt; L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(L-&gt;r[j] &gt; L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    swap(L,j,j+<span class="number">1</span>);</span><br><span class="line">                    flag=TRUE;	<span class="comment">//有数据交换,flag为TRUE</span></span><br><span class="line">                &#125;	<span class="comment">//else:L-&gt;r[j]&lt;=L-&gt;r[j+1]，flag仍然为FLASE，退出此元素循环遍历</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="简单选择排序：（选出最小值）n-i次关键字比较，从n-i-1个记录中选出关键字最小记录，与i记录交换"><a href="#简单选择排序：（选出最小值）n-i次关键字比较，从n-i-1个记录中选出关键字最小记录，与i记录交换" class="headerlink" title="简单选择排序：（选出最小值）n-i次关键字比较，从n-i+1个记录中选出关键字最小记录，与i记录交换"></a>简单选择排序：<span style="color: green;">（选出最小值）</span>n-i次关键字比较，从n-i+1个记录中选出关键字最小记录，与i记录交换</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. min变量用于临时存放当前最小值关键字下标</span></span><br><span class="line"><span class="comment">2. 从i位开始（初始化）</span></span><br><span class="line"><span class="comment">3. 从前往后循环比较其他位置，判断当前位小于已知最小值：赋值成为新最小值</span></span><br><span class="line"><span class="comment">4. 判断：i不等于min，则交换元素</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,min;	<span class="comment">//1</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;L-&gt;length;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min=i;	<span class="comment">//2</span></span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;=L-&gt;length;j++)	<span class="comment">//3</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(L-&gt;r[min] &gt; L-&gt;r[j])</span><br><span class="line">            &#123;</span><br><span class="line">                min=j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i != min)	<span class="comment">//4</span></span><br><span class="line">            &#123;</span><br><span class="line">                swap(L,i,min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="（重难点）直接插入排序（适合局部有序序列）：插入到已排好有序表中，得到一个新的、记录-1的有序表"><a href="#（重难点）直接插入排序（适合局部有序序列）：插入到已排好有序表中，得到一个新的、记录-1的有序表" class="headerlink" title="（重难点）直接插入排序（适合局部有序序列）：插入到已排好有序表中，得到一个新的、记录+1的有序表"></a><span style="color: red;">（重难点）</span>直接插入排序<span style="color: propule;">（适合局部有序序列）</span>：插入到已排好有序表中，得到一个新的、记录+1的有序表</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h3 id="（难点）改进算法类："><a href="#（难点）改进算法类：" class="headerlink" title="（难点）改进算法类："></a><span style="color: red;">（难点）</span>改进算法类：</h3><ol>
<li><h4 id="希尔排序（升级版插入排序）"><a href="#希尔排序（升级版插入排序）" class="headerlink" title="希尔排序（升级版插入排序）"></a>希尔排序（升级版插入排序）</h4><ol>
<li>希尔排序思路：（局部有序）<strong>跳跃分割</strong>若干区块，对各个区块单独<strong>插入排序</strong>，直到区块为<strong>1</strong><span style="color: green;">「基本有序：小前大后，不大不小居中」</span></li>
<li>&#x3D;&#x3D;增量&#x3D;&#x3D;(gap)选取：间隔位数<ol>
<li>gap &#x3D; n &#x2F; 2</li>
<li>gap&#x3D; n &#x2F; 3 +1</li>
<li>奇数</li>
<li>互质数</li>
</ol>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">增量方案：2</span></span><br><span class="line"><span class="comment">1. gap初始化为表长(1)，按照增量方案选取进行取值定义(2)</span></span><br><span class="line"><span class="comment">2. gap大于1:</span></span><br><span class="line"><span class="comment">    在增量区间中进行插入排序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> gap=L-&gt;length;	<span class="comment">//1(1)</span></span><br><span class="line">    <span class="keyword">while</span>(gap&gt;<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        gap = gap/<span class="number">3</span>+<span class="number">1</span>;	<span class="comment">//1(2)</span></span><br><span class="line">        <span class="keyword">for</span>(i = gap+ ; i&lt;=L-&gt;length ; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i=gap+<span class="number">1</span> ; i&lt;=L-&gt;length ; i++)	<span class="comment">//2</span></span><br><span class="line">            &#123;</span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><h4 id="堆排序（HeapSort）（依照特殊性质的完全二叉树「完全二叉性质5」）"><a href="#堆排序（HeapSort）（依照特殊性质的完全二叉树「完全二叉性质5」）" class="headerlink" title="堆排序（HeapSort）（依照特殊性质的完全二叉树「完全二叉性质5」）"></a>堆排序（HeapSort）<span style="color: green;">（依照特殊性质的完全二叉树「完全二叉性质5」）</span></h4><ol>
<li>大顶堆：每个结点的值都大于或等于其左右孩子结点的值</li>
<li>小顶堆：每个结点的值都小于或等于其左右孩子结点的值</li>
<li>堆排序算法思路：构造<strong>大顶堆</strong>，取出根结点<span style="color: green;">（最大值）</span>；再次构造<strong>次大顶堆</strong>，取出根结点；循环<strong>生成有序序列</strong><ol>
<li><p>对顺序表L进行构造大顶堆<span style="color: brown;">（两个for循环分别完成：构建 &amp;&amp; 调整）</span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">HeapSort</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1. 调用堆调整函数HeapAdjust 构建 初始大顶堆</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(i = L-&gt;length/<span class="number">2</span> ; i &gt; <span class="number">0</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        HeapAdjust(L,i,L-&gt;length);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    2. 堆排序：对原序列进行 调整 排序</span></span><br><span class="line"><span class="comment">        a. 调用交换，将堆顶和最后一个元素交换，进行序列调整</span></span><br><span class="line"><span class="comment">        b. 调用大顶堆处理，调整排序</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">for</span>(i=L-&gt;length ; i&gt;<span class="number">1</span> ; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(L,<span class="number">1</span>,i);</span><br><span class="line">        HeapAdjust(L,<span class="number">1</span>,i<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>大顶堆调整函数：<span style="color: red;">（关键点：根据&#x3D;&#x3D;二叉树性质5&#x3D;&#x3D;，当前结点序号 <strong>s</strong>，左孩子的序号一定是 <strong>2s</strong>，右孩子序号一定是 <strong>2s+1</strong> ）</span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1.  m标记长度，s标记当前结点序号，temp标记当前结点数据</span></span><br><span class="line"><span class="comment">2. </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">HeapAdjust</span><span class="params">(SqList *L,<span class="type">int</span> s,<span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp,j;</span><br><span class="line">    temp = L-&gt;r[s];</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">2</span>*s ; j &lt;=m ; j*=<span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;m &amp;&amp; L-&gt;r[j]&lt;L-&gt;r[j+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= L-&gt;r[j])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        L-&gt;r[s] = L-&gt;r[j];</span><br><span class="line">        s=j;</span><br><span class="line">    &#125;</span><br><span class="line">    L-&gt;r[s] = temp;	<span class="comment">//插入</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
<li><h4 id="（2路）归并排序（倒置的二叉树：两两合并排序后再合并）"><a href="#（2路）归并排序（倒置的二叉树：两两合并排序后再合并）" class="headerlink" title="（2路）归并排序（倒置的二叉树：两两合并排序后再合并）"></a>（2路）归并排序<span style="color: green;">（倒置的二叉树：两两合并排序后再合并）</span></h4><ol>
<li><p>二路归并思路：<strong>n个记录看作n个序列</strong>，两两归并后<strong>得到$\lfloor n&#x2F;2 \rfloor$个长度为2或1的有序子序列</strong>，再次循环归并直到得到<strong>一条长度为n的序列</strong></p>
</li>
<li><p>&#x3D;&#x3D;递归&#x3D;&#x3D;思路进行归并排序<span style="color: red;">（先拆分，后归并）</span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MSort</span><span class="params">(<span class="type">int</span> SR[] , <span class="type">int</span> TR1[] , <span class="type">int</span> s , <span class="type">int</span> t)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> m;</span><br><span class="line">    <span class="type">int</span> TR2[MAXSIZE+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">if</span>(s==t)</span><br><span class="line">    &#123;</span><br><span class="line">        TR1[s]=SR[s];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">子区间SR[i...m](下标用k存放)、子区间SR[m+1...n]（下标用j存放） ===&gt; TR[i....n]</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Merge</span><span class="params">(<span class="type">int</span> SR[] , <span class="type">int</span> TR)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j,k,i;</span><br><span class="line">    <span class="comment">/*****从小到大归并入TR*****/</span></span><br><span class="line">    <span class="keyword">for</span>(j=m+<span class="number">1</span>,k=i ; i&lt;=m &amp;&amp; j&lt;=n ; k++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(SR[i] &lt; SR[j])</span><br><span class="line">        &#123;</span><br><span class="line">            TR[k] = SR[i++];	<span class="comment">//左SR间元素并入</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            TR[k] = SR[j++];	<span class="comment">//右SR元素并入</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/******左右子序列进行元素判断******/</span></span><br><span class="line">    <span class="keyword">if</span>(i&lt;=m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">0</span> ; l&lt;=m-i ; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            TR[k+l] = SR[i+l]；</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(j&lt;=n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(l=<span class="number">0</span> ; l&lt;=n-j ; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            TR[k+l] = SR[j+l];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>&#x3D;&#x3D;迭代&#x3D;&#x3D;思路进行归并排序</p>
<ol>
<li>相邻元素归并：判断序列为奇偶，奇序列需要对最后一个单元素进行处理</li>
<li>数组复用：S数组当成T数组，T数组当成S数组</li>
<li>合并元素数从k &#x3D; 1成倍增加（log<sub>2</sub>n）<span style="color: green;">【1、1x2、2x2、4x2…】</span></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergeSort2</span><span class="params">(SqList *L)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> *TR=(<span class="type">int</span>*)<span class="built_in">malloc</span>(L-&gt;length * <span class="keyword">sizeof</span>(<span class="type">int</span>));	<span class="comment">//存放归并结果，动态生成归并数据空间</span></span><br><span class="line">    <span class="type">int</span> k=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(k&lt;L-&gt;length)</span><br><span class="line">    &#123;</span><br><span class="line">        MergePass(L-&gt;r , TR , k , L-&gt;length);	</span><br><span class="line">        k=<span class="number">2</span>*k;</span><br><span class="line">        MergePass(TR , L-&gt;r , k , L-&gt;length);</span><br><span class="line">        k=<span class="number">2</span>*k;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">MergePass</span><span class="params">(<span class="type">int</span> SR[] , <span class="type">int</span> TR[] , <span class="type">int</span> s , <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i=<span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="comment">/****调用两两归并(采用相邻两个元素归并的方式)****/</span></span><br><span class="line">    <span class="keyword">while</span>(i &lt;=  n<span class="number">-2</span>*s+<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Merge(SR , TR , i ,i+s<span class="number">-1</span> , i+<span class="number">2</span>*s<span class="number">-1</span>);</span><br><span class="line">        i = i+<span class="number">2</span>*s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    if(i &lt; n-s+1)</span></span><br><span class="line"><span class="comment">    &#123;</span></span><br><span class="line"><span class="comment">        Merge(SR , TR , i , i+s-1 , n);</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/******奇数序列，对最后一个元素进行处理*******/</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = i ; j &lt;= n ; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            TR[j] = SR[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h4><ol>
<li><p>快速排序处理函数<span style="color: blue;">（需要递归调用，因此以函数形式封装定义）</span></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QSort</span><span class="params">(SqList *L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span>(low &lt; high)</span><br><span class="line">    &#123;</span><br><span class="line">        pivot= Partition(L,low,high);	<span class="comment">//关键点：枢纽pivot值选取函数</span></span><br><span class="line">        QSort(L , low , pivot<span class="number">-1</span>);	<span class="comment">//对低子表递归排序</span></span><br><span class="line">        QSort(L , pivot+<span class="number">1</span> , high);	<span class="comment">//对高子表递归排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><span style="color: red;">选取关键字作为&#x3D;&#x3D;枢纽&#x3D;&#x3D;（pivot）函数</span></p>
<ol>
<li><p>关键思路：</p>
<ol>
<li>用low位值作为枢轴比较记录</li>
<li>分别从左右端交替比较</li>
<li>low &lt; key , low ++ ; low &gt; key , low &lt;-&gt; high</li>
<li>high &gt; key , high – ; high &lt; key , high &lt;-&gt; low</li>
<li>high &#x3D; low , 返回low值为函数得出的pivot</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Partition</span><span class="params">(SqList *L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pivotkey;</span><br><span class="line">    pivotekey = L-&gt;[low];	</span><br><span class="line">    <span class="comment">/***************/</span></span><br><span class="line">    <span class="keyword">while</span>(low&lt;high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(L-&gt;r[high] &gt; pivotekey)</span><br><span class="line">        &#123;</span><br><span class="line">            high--;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(L , high , low);</span><br><span class="line">        <span class="keyword">while</span>(low&lt;high &amp;&amp; L-&gt;r[low] &lt; pivotekey)</span><br><span class="line">        &#123;</span><br><span class="line">            low++;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(L , low , high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> low;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><h5 id="快速排序优化方案"><a href="#快速排序优化方案" class="headerlink" title="快速排序优化方案"></a>快速排序优化方案</h5><ol>
<li><p>优化选取枢轴值（提高大概率选取到为中间值）</p>
<ol>
<li>随机数选取法</li>
<li>三数取中法</li>
<li>九数取中法</li>
</ol>
</li>
<li><p>优化不必要的交换</p>
<ol>
<li>思路：<span style="color: blue;">（进行直接替换）</span>采用直接赋值替代函数swap()的调用</li>
</ol>
</li>
<li><p>优化小数组时排序方案</p>
<ol>
<li>思路：<span style="color: blue;">（避免大材小用）</span>设定<strong>阈值</strong>，对于小数组用<ins>直接插入法排序</ins></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">1. 选定合适阈值</span></span><br><span class="line"><span class="comment">2.判断数组大或小</span></span><br><span class="line"><span class="comment">    a. 大于阈值：调用快排（递归）</span></span><br><span class="line"><span class="comment">        -、选取枢轴</span></span><br><span class="line"><span class="comment">        -、低子表递归快排</span></span><br><span class="line"><span class="comment">        -、高子表递归快排</span></span><br><span class="line"><span class="comment">    b.	小于阈值：调用插排</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">define MAX_LENGTH_INSERT_SORT <span class="number">7</span>	<span class="comment">//设定合适的阈值</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">OSort</span><span class="params">(SqList *L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span>(high-low)&gt;MAX_LENGTH_INSERT_SORT)	<span class="comment">//大于阈值：快排</span></span><br><span class="line">    &#123;</span><br><span class="line">        pivot=Partiton1(L , low , high);	</span><br><span class="line">        QSort1(L , low , pivot<span class="number">-1</span> );</span><br><span class="line">        QSort1(L , pivot+<span class="number">1</span> , high);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>	<span class="comment">//小于阈值：插排</span></span><br><span class="line">    &#123;</span><br><span class="line">        InsertSort(L);	</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>优化递归操作</p>
<ol>
<li>思路：<span style="color: blue;">（减少递归，减少对栈空间的消耗）</span><strong>以迭代进行尾递归</strong>代替<strong>第二个递归排序</strong></li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">QSort2</span><span class="params">(SqList *L,<span class="type">int</span> low,<span class="type">int</span> high)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> pivot;</span><br><span class="line">    <span class="keyword">if</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">/**********/</span></span><br><span class="line">            <span class="comment">/**********/</span></span><br><span class="line">            low = pivot+<span class="number">1</span>;	<span class="comment">//尾递归</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        InsertSort(L);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>

            <!--[if lt IE 9]><script>document.createElement('audio');</script><![endif]-->
            <audio id="audio" loop="1" preload="auto" controls="controls" data-autoplay="true">
                <source type="audio/mpeg" src="">
            </audio>
            
                <ul id="audio-list" style="display:none">
                    
                        
                            <li title="0" data-url="https://link.hhtjim.com/163/1885536903.mp3"></li>
                        
                    
                        
                            <li title="1" data-url="https://link.hhtjim.com/163/1844681125.mp3"></li>
                        
                    
                        
                            <li title="2" data-url="https://link.hhtjim.com/163/1917044199.mp3"></li>
                        
                    
                        
                            <li title="3" data-url="https://link.hhtjim.com/163/34218762.mp3"></li>
                        
                    
                        
                            <li title="4" data-url="https://link.hhtjim.com/163/1927728096.mp3"></li>
                        
                    
                        
                            <li title="5" data-url="https://link.hhtjim.com/163/1454998244.mp3"></li>
                        
                    
                        
                            <li title="6" data-url="https://link.hhtjim.com/163/1805304382.mp3"></li>
                        
                    
                        
                            <li title="7" data-url="https://link.hhtjim.com/163/556203085.mp3"></li>
                        
                    
                        
                            <li title="8" data-url="https://link.hhtjim.com/163/515647696.mp3"></li>
                        
                    
                        
                            <li title="9" data-url="https://link.hhtjim.com/163/1917044199.mp3"></li>
                        
                    
                        
                            <li title="10" data-url="https://link.hhtjim.com/163/1912226948.mp3"></li>
                        
                    
                        
                            <li title="11" data-url="https://link.hhtjim.com/163/1807581976.mp3"></li>
                        
                    
                        
                            <li title="12" data-url="https://link.hhtjim.com/163/1807581976.mp3"></li>
                        
                    
                        
                            <li title="13" data-url="https://link.hhtjim.com/163/1895164923.mp3"></li>
                        
                    
                        
                            <li title="14" data-url="https://link.hhtjim.com/163/1858118347.mp3"></li>
                        
                    
                        
                            <li title="15" data-url="https://link.hhtjim.com/163/1320990503.mp3"></li>
                        
                    
                        
                            <li title="16" data-url="https://link.hhtjim.com/163/1816323939.mp3"></li>
                        
                    
                        
                            <li title="17" data-url="https://link.hhtjim.com/163/1865566215.mp3"></li>
                        
                    
                        
                            <li title="18" data-url="https://link.hhtjim.com/163/1501450521.mp3"></li>
                        
                    
                        
                            <li title="19" data-url="https://link.hhtjim.com/163/1805428732.mp3"></li>
                        
                    
                        
                            <li title="20" data-url="https://link.hhtjim.com/163/486195958.mp3"></li>
                        
                    
                        
                            <li title="21" data-url="https://link.hhtjim.com/163/1498788913.mp3"></li>
                        
                    
                        
                            <li title="22" data-url="https://link.hhtjim.com/163/1383023012.mp3"></li>
                        
                    
                        
                            <li title="23" data-url="https://link.hhtjim.com/163/1367333218.mp3"></li>
                        
                    
                        
                            <li title="24" data-url="https://link.hhtjim.com/163/1864872333.mp3"></li>
                        
                    
                        
                            <li title="25" data-url="https://link.hhtjim.com/163/443292353.mp3"></li>
                        
                    
                        
                            <li title="26" data-url="https://link.hhtjim.com/163/1803880020.mp3"></li>
                        
                    
                        
                            <li title="27" data-url="https://link.hhtjim.com/163/1841788961.mp3"></li>
                        
                    
                        
                            <li title="28" data-url="https://link.hhtjim.com/163/1841482769.mp3"></li>
                        
                    
                        
                            <li title="29" data-url="https://link.hhtjim.com/163/1472273576.mp3"></li>
                        
                    
                        
                            <li title="30" data-url="https://link.hhtjim.com/163/1860652524.mp3"></li>
                        
                    
                        
                            <li title="31" data-url="https://link.hhtjim.com/163/1914467361.mp3"></li>
                        
                    
                </ul>
            
        </div>
        
    <div id="gitalk-container" class="comment link"
		data-enable="true"
        data-ae="true"
        data-ci="1ba887259d3c06430ee3"
        data-cs="0a6cd21e1f2ab2e742f162eb12d4ae640dcfc57f"
        data-r="dxhm.github.io"
        data-o="DXHM"
        data-a="DXHM"
        data-d="true"
    >查看评论</div>


    </div>
    
        <div class="side">
			<ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.</span> <span class="toc-text">一、数据结构绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-amp-%E6%9C%AF%E8%AF%AD"><span class="toc-number">1.0.1.</span> <span class="toc-text">基本概念&amp;术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%EF%BC%88%E6%8F%8F%E8%BF%B0%E5%AE%A2%E8%A7%82%E4%BA%8B%E7%89%A9%E7%9A%84%E7%AC%A6%E5%8F%B7%EF%BC%8C%E8%83%BD%E8%A2%AB%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%AF%86%E5%88%AB%E5%B9%B6%E6%93%8D%E4%BD%9C%E7%9A%84%E7%AC%A6%E5%8F%B7%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.0.1.1.</span> <span class="toc-text">数据（描述客观事物的符号，能被计算机识别并操作的符号集合）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%EF%BC%88%E2%80%9C%E8%AE%B0%E5%BD%95%E2%80%9D%EF%BC%89%EF%BC%9A%E7%BB%84%E6%88%90%E6%95%B0%E6%8D%AE%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8D%95%E4%BD%8D"><span class="toc-number">1.0.1.2.</span> <span class="toc-text">数据元素（“记录”）：组成数据的基本单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%A1%B9%EF%BC%9A%E8%8B%A5%E5%B9%B2%E6%95%B0%E6%8D%AE%E9%A1%B9%E7%BB%84%E6%88%90%E4%B8%80%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%EF%BC%8C%E6%98%AF%E6%95%B0%E6%8D%AE%E4%B8%8D%E5%8F%AF%E5%88%86%E5%89%B2%E7%9A%84%E6%9C%80%E5%B0%8F%E5%8D%95%E4%BD%8D"><span class="toc-number">1.0.1.3.</span> <span class="toc-text">数据项：若干数据项组成一个数据元素，是数据不可分割的最小单位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%EF%BC%9A%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%90%E9%9B%86%EF%BC%88%E7%9B%B8%E5%90%8C%E6%80%A7%E8%B4%A8%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88%EF%BC%89"><span class="toc-number">1.0.1.4.</span> <span class="toc-text">数据对象：数据的子集（相同性质的数据元素的集合）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%9A%E5%AD%98%E5%9C%A8%E4%B8%80%E7%A7%8D%E6%88%96%E5%A4%9A%E7%A7%8D%E7%89%B9%E5%AE%9A%E5%85%B3%E7%B3%BB%E7%9A%84%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">1.0.1.5.</span> <span class="toc-text">数据结构：存在一种或多种特定关系的数据元素的集合</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.0.2.</span> <span class="toc-text">结构分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.2.1.</span> <span class="toc-text">存储类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84%EF%BC%9A-%E9%9D%A2%E5%90%91%E9%97%AE%E9%A2%98-%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">1.0.2.1.1.</span> <span class="toc-text">逻辑结构：(面向问题)数据元素之间的关系</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84%EF%BC%9A%E4%B8%80%E5%AF%B9%E4%B8%80"><span class="toc-number">1.0.2.1.1.1.</span> <span class="toc-text">线性结构：一对一</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%9D%9E%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%84"><span class="toc-number">1.0.2.1.1.2.</span> <span class="toc-text">非线性结构</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E7%BB%93%E6%9E%84%EF%BC%9A-%E9%9D%A2%E5%90%91%E8%AE%A1%E7%AE%97%E6%9C%BA-%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.0.2.1.2.</span> <span class="toc-text">物理结构：(面向计算机)在计算机中的存储方式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.0.2.2.</span> <span class="toc-text">数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8E%9F%E5%AD%90%E7%B1%BB%E5%9E%8B%EF%BC%88%E4%B8%8D%E5%8F%AF%E5%88%86%E8%A7%A3%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B%EF%BC%89%EF%BC%9A%E6%95%B4%E5%9E%8B%E3%80%81%E5%AE%9E%E5%9E%8B%E3%80%81%E5%AD%97%E7%AC%A6%E5%9E%8B"><span class="toc-number">1.0.2.2.1.</span> <span class="toc-text">原子类型（不可分解的基本类型）：整型、实型、字符型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%EF%BC%88%E5%8F%AF%E5%88%86%E8%A7%A3%E7%BB%84%E5%90%88%E7%B1%BB%E5%9E%8B%EF%BC%89%EF%BC%9A%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.0.2.2.2.</span> <span class="toc-text">结构类型（可分解组合类型）：结构体</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-ADT%EF%BC%88%E5%BE%AE%E5%85%83%E6%80%9D%E6%83%B3%EF%BC%89%EF%BC%9A%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%A6%E6%A8%A1%E5%9E%8B%E5%8F%8A%E5%AE%9A%E4%B9%89%E5%9C%A8%E8%AF%A5%E6%A8%A1%E5%9E%8B%E4%B8%8A%E7%9A%84%E4%B8%80%E7%BB%84%E6%93%8D%E4%BD%9C"><span class="toc-number">1.0.2.2.3.</span> <span class="toc-text">抽象数据类型 ADT（微元思想）：一个数学模型及定义在该模型上的一组操作</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">二、算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A"><span class="toc-number">2.0.0.1.</span> <span class="toc-text">算法的定义：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A%EF%BC%88%E4%BA%94%E4%B8%AA%E5%9F%BA%E6%9C%AC%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-number">2.0.0.2.</span> <span class="toc-text">算法的特性：（五个基本特性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E8%AE%BE%E8%AE%A1%E7%9A%84%E8%A6%81%E6%B1%82%EF%BC%9A"><span class="toc-number">2.0.0.3.</span> <span class="toc-text">算法设计的要求：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%EF%BC%89%E5%BA%A6%E9%87%8F%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.0.0.4.</span> <span class="toc-text">（算法效率的）度量方法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#x3D-x3D-%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E4%BC%B0%E7%AE%97%E6%95%88%E7%8E%87-x3D-x3D-%E8%A7%84%E8%8C%83%EF%BC%9A%E5%87%BD%E6%95%B0%E7%9A%84%E6%B8%90%E8%BF%9B%E5%A2%9E%E9%95%BF%EF%BC%88%E5%8D%95%E8%B0%83%E9%80%92%E5%A2%9E%EF%BC%89"><span class="toc-number">2.0.0.5.</span> <span class="toc-text">&#x3D;&#x3D;时间复杂度估算效率&#x3D;&#x3D;规范：函数的渐进增长（单调递增）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">2.0.0.6.</span> <span class="toc-text">算法时间复杂度</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">3.</span> <span class="toc-text">三、线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%EF%BC%88List%EF%BC%89%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A%E9%9B%B6-x2F-%E5%A4%9A%E4%B8%AA%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E7%9A%84%E6%9C%89%E9%99%90%E5%BA%8F%E5%88%97"><span class="toc-number">3.0.1.</span> <span class="toc-text">线性表（List）的定义：零&#x2F;多个数据元素的有限序列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#List%E4%B8%BB%E8%A6%81%E6%80%A7%E8%B4%A8%EF%BC%9A"><span class="toc-number">3.0.1.1.</span> <span class="toc-text">List主要性质：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E9%95%BF%E5%BA%A6%EF%BC%9A%E5%85%83%E7%B4%A0%E4%B8%AA%E6%95%B0-n"><span class="toc-number">3.0.1.2.</span> <span class="toc-text">线性表长度：元素个数 n</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A9%BA%E8%A1%A8%EF%BC%9An-x3D-0"><span class="toc-number">3.0.1.3.</span> <span class="toc-text">空表：n&#x3D;0</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E5%BA%8F%EF%BC%9A%EF%BC%88ai%EF%BC%89%E4%B8%AD%E7%9A%84i"><span class="toc-number">3.0.1.4.</span> <span class="toc-text">位序：（ai）中的i</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">3.0.2.</span> <span class="toc-text">线性表的抽象数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E5%8F%82%E5%8E%9F%E5%88%99%EF%BC%9A-%E4%BC%A0%E9%80%92%E4%B8%80%E4%B8%AA%E5%8F%82%E6%95%B0%E7%BB%99%E5%87%BD%E6%95%B0%E6%97%B6%EF%BC%8C%E5%8F%82%E6%95%B0%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%9C%A8%E5%87%BD%E6%95%B0%E5%86%85%E8%A2%AB%E6%94%B9%E5%8A%A8%E5%86%B3%E5%AE%9A%E4%BA%86%E4%BD%BF%E7%94%A8%E4%BB%80%E4%B9%88%E4%BC%A0%E5%8F%82%E5%BD%A2%E5%BC%8F"><span class="toc-number">3.0.2.1.</span> <span class="toc-text">传参原则：(传递一个参数给函数时，参数会不会在函数内被改动决定了使用什么传参形式)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.0.3.</span> <span class="toc-text">线性表的顺序存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%80%A7%E8%B4%A8%EF%BC%9A%E7%94%A8%E4%B8%80%E6%AE%B5-x3D-x3D-%E5%9C%B0%E5%9D%80%E8%BF%9E%E7%BB%AD-x3D-x3D-%E7%9A%84-x3D-x3D-%E5%AD%98%E5%82%A8%E5%8D%95%E5%85%83-x3D-x3D-%E4%BE%9D%E6%AC%A1%E5%AD%98%E5%82%A8%E7%BA%BF%E8%A1%A8%E7%9A%84-x3D-x3D-%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0-x3D-x3D"><span class="toc-number">3.0.3.1.</span> <span class="toc-text">定义与性质：用一段&#x3D;&#x3D;地址连续&#x3D;&#x3D;的&#x3D;&#x3D;存储单元&#x3D;&#x3D;依次存储线表的&#x3D;&#x3D;数据元素&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%B0%E5%9D%80%E7%9A%84%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%EF%BC%9A-x3D-x3D-%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%E7%9A%84%E5%BA%8F%E5%8F%B7-x3D-x3D-%E4%B8%8E%E5%AD%98%E6%94%BE%E7%9A%84%E6%95%B0%E7%BB%84-x3D-x3D-%E4%B8%8B%E6%A0%87-x3D-x3D-%E5%AD%98%E5%9C%A8-x3D-x3D-%E5%AF%B9%E5%BA%94-x3D-x3D-%E5%85%B3%E7%B3%BB"><span class="toc-number">3.0.3.2.</span> <span class="toc-text">地址的计算方法：&#x3D;&#x3D;数据元素的序号&#x3D;&#x3D;与存放的数组&#x3D;&#x3D;下标&#x3D;&#x3D;存在&#x3D;&#x3D;对应&#x3D;&#x3D;关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4"><span class="toc-number">3.0.3.3.</span> <span class="toc-text">顺序存储结构的查找、插入、删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">3.0.4.</span> <span class="toc-text">线性表的链式存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9An%E4%B8%AA%E7%BB%93%E7%82%B9%E9%93%BE%E7%BB%93%E6%88%90%E4%B8%80%E4%B8%AA%E9%93%BE%E8%A1%A8"><span class="toc-number">3.0.4.1.</span> <span class="toc-text">链式存储结构的定义：n个结点链结成一个链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84-%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">3.0.4.2.</span> <span class="toc-text">链式存储结构-建立单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E8%AF%BB%E5%8F%96%EF%BC%9A%E2%80%9C%E5%B7%A5%E4%BD%9C%E6%8C%87%E9%92%88%E5%90%8E%E7%A7%BB%E2%80%9D%E9%81%8D%E5%8E%86%E6%9F%A5%E6%89%BE%EF%BC%88GetElem%EF%BC%89"><span class="toc-number">3.0.4.3.</span> <span class="toc-text">单链表的读取：“工作指针后移”遍历查找（GetElem）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%8F%92%E5%85%A5%E3%80%81%E5%88%A0%E9%99%A4%EF%BC%9AO-n-%E3%80%90%E6%8F%92%E5%88%A0%E6%93%8D%E4%BD%9C%E8%B6%8A%E9%A2%91%E7%B9%81%EF%BC%8C%E6%95%88%E7%8E%87%E4%BC%98%E5%8A%BF%E8%B6%8A%E6%98%8E%E6%98%BE%E3%80%91"><span class="toc-number">3.0.4.4.</span> <span class="toc-text">单链表的插入、删除：O(n)【插删操作越频繁，效率优势越明显】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%9B%E5%BB%BA%EF%BC%9A%E5%8A%A8%E6%80%81%E7%94%9F%E6%88%90%E9%93%BE%E8%A1%A8%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.0.4.5.</span> <span class="toc-text">单链表的整表创建：动态生成链表的过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E7%9A%84%E6%95%B4%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="toc-number">3.0.4.6.</span> <span class="toc-text">单链表的整表删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E9%93%BE%E8%A1%A8%E3%80%90%E6%B8%B8%E6%A0%87%E5%AE%9E%E7%8E%B0%E6%B3%95%E3%80%91"><span class="toc-number">3.0.4.7.</span> <span class="toc-text">静态链表【游标实现法】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%8D%95%E9%93%BE%E8%A1%A8%E5%B0%BE%E6%8E%A5%E4%B8%8A%E5%A4%B4%E6%9E%84%E6%88%90%E4%B8%80%E4%B8%AA%E7%8E%AF"><span class="toc-number">3.0.4.8.</span> <span class="toc-text">循环链表：单链表尾接上头构成一个环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8%EF%BC%9A%E5%A2%9E%E5%8A%A0%E4%B8%80%E4%B8%AA%E7%9B%B4%E6%8E%A5%E5%89%8D%E9%A9%B1%E6%8C%87%E9%92%88prior%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-number">3.0.4.9.</span> <span class="toc-text">双向链表：增加一个直接前驱指针prior的单链表</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="toc-number">4.</span> <span class="toc-text">四、栈与队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%EF%BC%88LIFO%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">4.0.1.</span> <span class="toc-text">栈（LIFO结构）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A%E4%BB%85%E5%9C%A8%E8%A1%A8%E5%B0%BE%EF%BC%88%E6%A0%88%E9%A1%B6top%EF%BC%89%E6%8F%92%E5%85%A5-amp-%E5%88%A0%E9%99%A4%E7%9A%84%E5%90%8E%E8%BF%9B%E5%85%88%E5%87%BA-x3D-x3D-%E7%BA%BF%E6%80%A7%E8%A1%A8-x3D-x3D"><span class="toc-number">4.0.1.1.</span> <span class="toc-text">定义：仅在表尾（栈顶top）插入&amp;删除的后进先出&#x3D;&#x3D;线性表&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-number">4.0.1.2.</span> <span class="toc-text">顺序栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%A0%88"><span class="toc-number">4.0.1.3.</span> <span class="toc-text">链栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">4.0.1.4.</span> <span class="toc-text">栈的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97%EF%BC%88FIFO%EF%BC%89"><span class="toc-number">4.0.2.</span> <span class="toc-text">队列（FIFO）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%EF%BC%9A%E5%8F%AA%E5%85%81%E8%AE%B8%E5%9C%A8%E4%B8%80%E6%AE%B5%E6%8F%92%E5%85%A5%E5%8F%A6%E4%B8%80%E7%AB%AF%E5%88%A0%E9%99%A4%E7%9A%84-%E5%85%88%E8%BF%9B%E5%85%88%E5%87%BA-x3D-x3D-%E6%8E%92%E9%98%9F-x3D-x3D-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">4.0.2.1.</span> <span class="toc-text">定义：只允许在一段插入另一端删除的 先进先出 &#x3D;&#x3D;排队&#x3D;&#x3D; 线性表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97-x3D-x3D-gt-%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%EF%BC%88%E5%A4%B4%E5%B0%BE%E7%9B%B8%E6%8E%A5%E7%9A%84%E6%94%B9%E8%BF%9B%E7%89%88%E9%A1%BA%E5%BA%8F%E9%98%9F%EF%BC%8C%E8%A7%A3%E5%86%B3%E2%80%9D%E5%81%87%E6%BA%A2%E5%87%BA%E2%80%9C%EF%BC%89"><span class="toc-number">4.0.2.2.</span> <span class="toc-text">顺序队列 &#x3D;&#x3D;&gt; 循环队列（头尾相接的改进版顺序队，解决”假溢出“）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%EF%BC%88%E5%B0%BE%E8%BF%9B%E5%A4%B4%E5%87%BA%E7%9A%84%E5%8D%95%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">4.0.2.3.</span> <span class="toc-text">链队（尾进头出的单链表）</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E4%B8%B2"><span class="toc-number">5.</span> <span class="toc-text">五、串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%9A%E7%94%B1-x3D-x3D-%E9%9B%B6%E4%B8%AA-x3D-x3D-%E6%88%96-x3D-x3D-%E5%A4%9A%E4%B8%AA-x3D-x3D-%E5%AD%97%E7%AC%A6%E7%BB%84%E6%88%90%E7%9A%84-x3D-x3D-%E6%9C%89%E9%99%90%E5%BA%8F%E5%88%97-x3D-x3D-%EF%BC%88%E8%AE%B0%E4%BD%9C%EF%BC%9As-x3D-%E2%80%9Ca1-a2-%E2%80%A6-an%E2%80%9D-n%E2%89%A50-%EF%BC%89"><span class="toc-number">5.0.1.</span> <span class="toc-text">字符串的定义：由&#x3D;&#x3D;零个&#x3D;&#x3D;或&#x3D;&#x3D;多个&#x3D;&#x3D;字符组成的&#x3D;&#x3D;有限序列&#x3D;&#x3D;（记作：s&#x3D;“a1 a2 … an”(n≥0)）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%AF%94%E8%BE%83%EF%BC%9A%E9%80%90%E4%BD%8D%E6%AF%94%E8%BE%83"><span class="toc-number">5.0.2.</span> <span class="toc-text">串的比较：逐位比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">5.0.3.</span> <span class="toc-text">串的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%E7%AE%97%E6%B3%95%EF%BC%88%E5%AD%90%E4%B8%B2%E7%9A%84%E5%AE%9A%E4%BD%8D%EF%BC%89"><span class="toc-number">5.0.4.</span> <span class="toc-text">串的模式匹配算法（子串的定位）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AD%E3%80%81%E6%A0%91"><span class="toc-number">6.</span> <span class="toc-text">六、树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89%EF%BC%88%E4%B8%80%E5%AF%B9%E5%A4%9A%EF%BC%89"><span class="toc-number">6.0.1.</span> <span class="toc-text">树的定义（一对多）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.0.2.</span> <span class="toc-text">树的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AE%9A%E4%B9%89-amp-%E7%89%B9%E7%82%B9"><span class="toc-number">6.0.3.</span> <span class="toc-text">二叉树的定义&amp;特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">6.0.4.</span> <span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">6.0.5.</span> <span class="toc-text">二叉树存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%88%E4%BB%8E%E6%A0%B9%E7%BB%93%E7%82%B9%E5%87%BA%E5%8F%91%EF%BC%8C%E6%8C%89%E7%85%A7%E4%B8%8D%E5%90%8C%E6%AC%A1%E5%BA%8F%EF%BC%8C%E5%AF%B9%E6%AF%8F%E4%B8%AA%E7%BB%93%E7%82%B9%E8%BF%9B%E8%A1%8C%E8%AE%BF%E9%97%AE%EF%BC%89"><span class="toc-number">6.0.6.</span> <span class="toc-text">二叉树的遍历（从根结点出发，按照不同次序，对每个结点进行访问）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%B1%95%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%90%E7%BB%8F%E5%A4%84%E7%90%86%E5%90%8E%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E8%99%9A%E7%BB%93%E7%82%B9%E2%80%9C-%E2%80%9D%E8%A1%A8%E7%A4%BA%E7%A9%BANULL%E3%80%91"><span class="toc-number">6.0.7.</span> <span class="toc-text">扩展二叉树的建立【经处理后的二叉树：虚结点“#”表示空NULL】</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E5%8A%A0%E4%B8%8A%E6%A0%87%E5%BF%97%E5%9F%9Ftag%EF%BC%8C%E8%BF%9B%E8%A1%8C%E5%88%87%E6%8D%A2-x3D-x3D-%E5%AD%A9%E5%AD%90-x3D-x3D-%E5%92%8C-x3D-x3D-%E5%89%8D%E5%90%8E-x3D-x3D-%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="toc-number">6.0.8.</span> <span class="toc-text">线索二叉树（加上标志域tag，进行切换&#x3D;&#x3D;孩子&#x3D;&#x3D;和&#x3D;&#x3D;前后&#x3D;&#x3D;的二叉树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">6.0.9.</span> <span class="toc-text">树、森林、二叉树的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91-%E8%BD%AC%E6%8D%A2%E4%B8%BA-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F%EF%BC%9A%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%EF%BC%89%E3%80%90%E5%8F%B3%E5%85%84%E5%8F%98%E5%8F%B3%E5%AD%A9%E5%AD%90%E3%80%91"><span class="toc-number">6.0.9.1.</span> <span class="toc-text">树 转换为 二叉树（转换方式：二叉链表）【右兄变右孩子】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97-%E8%BD%AC%E6%8D%A2%E4%B8%BA-%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A1%E3%80%81-x3D-x3D-%E6%AF%8F%E6%A3%B5%E6%A0%91-x3D-x3D-%E8%BD%AC%E6%88%90%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%822%E3%80%81%E5%90%8E%E4%B8%80%E6%A3%B5%E6%A0%91-x3D-x3D-%E6%A0%B9%E7%BB%93%E7%82%B9-x3D-x3D-%E4%BD%9C%E4%B8%BA-x3D-x3D-%E5%89%8D%E4%B8%80%E4%B8%AA%E6%A0%B9%E7%9A%84%E5%8F%B3%E5%AD%A9%E5%AD%90-x3D-x3D-%E3%80%82"><span class="toc-number">6.0.9.2.</span> <span class="toc-text">森林 转换为 二叉树：1、&#x3D;&#x3D;每棵树&#x3D;&#x3D;转成二叉树。2、后一棵树&#x3D;&#x3D;根结点&#x3D;&#x3D;作为&#x3D;&#x3D;前一个根的右孩子&#x3D;&#x3D;。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%BD%AC%E6%8D%A2-%E6%A0%91%EF%BC%9A%EF%BC%88%E8%BD%AC%E6%8D%A2%E6%96%B9%E5%BC%8F%EF%BC%9A%E9%80%86%E4%BA%8C%E5%8F%89%E9%93%BE%E8%A1%A8%EF%BC%89%E3%80%90%E5%8F%B3%E5%AD%A9%E5%AD%90%E5%8F%98%E5%8F%B3%E5%85%84%E3%80%91"><span class="toc-number">6.0.9.3.</span> <span class="toc-text">二叉树 转换 树：（转换方式：逆二叉链表）【右孩子变右兄】</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91-%E8%BD%AC%E6%8D%A2-%E6%A3%AE%E6%9E%97%EF%BC%9A1%E3%80%81-x3D-x3D-%E5%88%A4%E6%96%AD-x3D-x3D-%EF%BC%9A%E6%A0%B9%E6%9C%89%E6%97%A0%E5%8F%B3%E5%AD%A9%E5%AD%90%E3%80%822%E3%80%81%E4%BB%8E%E6%A0%B9%E5%BC%80%E5%A7%8B%EF%BC%8C-x3D-x3D-%E9%81%87%E5%8F%B3-x3D-x3D-%E5%AD%A9%E5%AD%90-x3D-x3D-%E6%96%AD%E5%BC%80-x3D-x3D"><span class="toc-number">6.0.9.4.</span> <span class="toc-text">二叉树 转换 森林：1、&#x3D;&#x3D;判断&#x3D;&#x3D;：根有无右孩子。2、从根开始，&#x3D;&#x3D;遇右&#x3D;&#x3D;孩子&#x3D;&#x3D;断开&#x3D;&#x3D;</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%9A%E5%85%88%E6%A0%B9%EF%BC%8C%E5%90%8E%E6%A0%B9%EF%BC%9B%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%EF%BC%9A%E5%89%8D%E5%BA%8F%EF%BC%8C%E5%90%8E%E5%BA%8F"><span class="toc-number">6.0.9.5.</span> <span class="toc-text">森林的遍历：先根，后根；树的遍历：前序，后序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%EF%BC%88%E6%9C%80%E4%BC%98%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="toc-number">6.0.10.</span> <span class="toc-text">哈夫曼树（最优二叉树）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">6.0.10.1.</span> <span class="toc-text">哈夫曼树概念：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%94%9F%E6%88%90%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">6.0.10.2.</span> <span class="toc-text">哈夫曼树生成方式：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F%EF%BC%88%E6%97%A0%E6%8D%9F%E5%8E%8B%E7%BC%A9%E3%80%81%E6%95%B0%E6%8D%AE%E4%BC%A0%E8%BE%93%E4%BC%98%E5%8C%96%EF%BC%89"><span class="toc-number">6.0.11.</span> <span class="toc-text">哈夫曼树的应用：哈夫曼编码方式（无损压缩、数据传输优化）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%83%E3%80%81%E5%9B%BE%EF%BC%88%E6%A6%82%E5%BF%B5%E5%A4%9A%EF%BC%8C%E7%AE%97%E6%B3%95%E8%BE%83%E4%B8%BA%E5%A4%8D%E6%9D%82%EF%BC%89"><span class="toc-number">7.</span> <span class="toc-text">七、图（概念多，算法较为复杂）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E6%9C%AF%E8%AF%AD"><span class="toc-number">7.0.1.</span> <span class="toc-text">图的定义与术语</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E6%96%B9%E5%90%91%E5%8C%BA%E5%88%86%EF%BC%9A"><span class="toc-number">7.0.1.1.</span> <span class="toc-text">按方向区分：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%8E%AF%EF%BC%9A%E9%A6%96%E5%B0%BE%E5%90%8C%E9%A1%B6%E7%82%B9"><span class="toc-number">7.0.1.2.</span> <span class="toc-text">环：首尾同顶点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%EF%BC%88%E5%B8%A6%E6%9D%83%E5%9B%BE%EF%BC%89%EF%BC%9A%E8%BE%B9-x2F-%E5%BC%A7%E4%B8%8A%E5%B8%A6%E6%9D%83"><span class="toc-number">7.0.1.3.</span> <span class="toc-text">网（带权图）：边&#x2F;弧上带权</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E8%BE%B9-x2F-%E5%BC%A7%E7%9A%84%E6%95%B0%E9%87%8F%E5%8C%BA%E5%88%86%EF%BC%88%E8%B7%AF%E5%BE%84%E9%95%BF%E5%BA%A6%EF%BC%89%EF%BC%9A%E7%A8%80%E7%96%8F%E5%9B%BE%E3%80%81%E7%A8%A0%E5%AF%86%E5%9B%BE"><span class="toc-number">7.0.1.4.</span> <span class="toc-text">按边&#x2F;弧的数量区分（路径长度）：稀疏图、稠密图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E4%BA%94%E7%A7%8D%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">7.0.2.</span> <span class="toc-text">图的五种存储结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5"><span class="toc-number">7.0.2.1.</span> <span class="toc-text">邻接矩阵</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E6%95%B0%E7%BB%84-%E9%93%BE%E8%A1%A8%EF%BC%89"><span class="toc-number">7.0.2.2.</span> <span class="toc-text">邻接表（数组+链表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8%EF%BC%88%E8%BE%83%E9%9A%BE%E7%90%86%E8%A7%A3%EF%BC%89%EF%BC%88%E9%82%BB%E6%8E%A5%E8%A1%A8-%E9%80%86%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89"><span class="toc-number">7.0.2.3.</span> <span class="toc-text">十字链表（较难理解）（邻接表+逆邻接表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E9%87%8D%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%88%E6%97%A0%E5%90%91%E5%9B%BE%EF%BC%9A%E6%96%B9%E4%BE%BF%E5%AF%B9%E8%BE%B9%E6%93%8D%E4%BD%9C%E7%9A%84%E6%94%B9%E8%BF%9B%E7%89%88%E9%82%BB%E6%8E%A5%E8%A1%A8%EF%BC%89"><span class="toc-number">7.0.2.4.</span> <span class="toc-text">多重邻接表（无向图：方便对边操作的改进版邻接表）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%B9%E9%9B%86%E6%95%B0%E7%BB%84%EF%BC%88%E4%B8%A4%E4%B8%AA%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%EF%BC%89"><span class="toc-number">7.0.2.5.</span> <span class="toc-text">边集数组（两个一维数组）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">7.0.3.</span> <span class="toc-text">图的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">7.0.4.</span> <span class="toc-text">图的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">7.0.4.1.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95prim%EF%BC%9A%E4%BB%8E%E4%B8%80%E7%82%B9%E5%87%BA%E5%8F%91%EF%BC%8C%E9%80%90%E6%AD%A5%E6%89%BE%E5%B7%B2%E7%9F%A5%E9%A1%B6%E7%82%B9%E4%BE%9D%E9%99%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%9D%83%E5%80%BC%E8%BE%B9"><span class="toc-number">7.0.4.1.1.</span> <span class="toc-text">普里姆算法prim：从一点出发，逐步找已知顶点依附的最小权值边</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95kruskal%EF%BC%9A%E6%8A%8A%E5%9B%BE%E4%B8%AD%E6%9C%80%E7%9F%AD%E8%BE%B9%E4%B8%80%E4%B8%AA%E4%B8%AA%E6%8C%91%E5%87%BA%E6%9D%A5%EF%BC%88%E4%B8%8A%E5%B8%9D-x2F-%E5%85%A8%E5%B1%80%E8%A7%86%E8%A7%92%EF%BC%89"><span class="toc-number">7.0.4.1.2.</span> <span class="toc-text">克鲁斯卡尔算法kruskal：把图中最短边一个个挑出来（上帝&#x2F;全局视角）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%EF%BC%88%E6%BA%90%E7%82%B9%E5%88%B0%E7%BB%88%E7%82%B9%E6%9D%83%E5%80%BC%E4%B9%8B%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9A%84%E8%B7%AF%E5%BE%84%EF%BC%89"><span class="toc-number">7.0.4.2.</span> <span class="toc-text">最短路径（源点到终点权值之和最小的路径）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95dijkstra%EF%BC%88%E5%8D%95%E6%BA%90%E9%A1%B6%E7%82%B9%E6%9F%A5%E6%89%BE%EF%BC%89"><span class="toc-number">7.0.4.2.1.</span> <span class="toc-text">迪杰斯特拉算法dijkstra（单源顶点查找）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7%E7%AE%97%E6%B3%95floyd%EF%BC%9A%EF%BC%88%E5%BA%94%E7%94%A8%E7%9F%A9%E9%98%B5%E7%9A%84%E5%8F%98%E5%8C%96%EF%BC%89%E4%BA%8C%E9%87%8D%E5%BE%AA%E7%8E%AF%E5%88%9D%E5%A7%8B%E5%8C%96-%E4%B8%89%E9%87%8D%E5%BE%AA%E7%8E%AF%E4%BF%AE%E6%AD%A3-%E3%80%90%E9%80%82%E5%90%88%EF%BC%9A%E6%B1%82%E6%89%80%E6%9C%89%E9%A1%B6%E7%82%B9%E5%88%B0%E4%BB%BB%E6%84%8F%E9%A1%B6%E7%82%B9%E3%80%91"><span class="toc-number">7.0.4.2.2.</span> <span class="toc-text">弗洛伊德算法floyd：（应用矩阵的变化）二重循环初始化 + 三重循环修正 【适合：求所有顶点到任意顶点】</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E6%98%BE%E7%A4%BA%EF%BC%9A%E9%81%8D%E5%8E%86%E7%9F%A9%E9%98%B5"><span class="toc-number">7.0.4.2.3.</span> <span class="toc-text">最短路径显示：遍历矩阵</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E7%A8%8B%E8%A7%84%E5%88%92%EF%BC%88%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%EF%BC%89"><span class="toc-number">7.0.4.3.</span> <span class="toc-text">工程规划（有向无环图）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%88AOV%E7%BD%91%EF%BC%89"><span class="toc-number">7.0.4.3.1.</span> <span class="toc-text">拓扑排序（AOV网）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%88AOE%E7%BD%91%EF%BC%89%EF%BC%88%E5%B8%A6%E6%9D%83%E6%9C%89%E5%90%91%E5%9B%BE%EF%BC%89"><span class="toc-number">7.0.4.3.2.</span> <span class="toc-text">关键路径（AOE网）（带权有向图）</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%AB%E3%80%81%E6%9F%A5%E6%89%BE"><span class="toc-number">8.</span> <span class="toc-text">八、查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%A1%A8%EF%BC%9A%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8-%E5%8F%AA%E6%9F%A5-%E3%80%81%E5%8A%A8%E6%80%81%E6%9F%A5%E6%89%BE%E8%A1%A8-%E6%9F%A5%E3%80%81%E5%A2%9E%E3%80%81%E5%88%A0"><span class="toc-number">8.0.1.</span> <span class="toc-text">查找表：静态查找表[只查]、动态查找表[查、增、删]</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%88key%EF%BC%89%EF%BC%9A%E4%B8%BB%E5%85%B3%E9%94%AE%E5%AD%97-amp-%E6%AC%A1%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">8.0.2.</span> <span class="toc-text">关键字（key）：主关键字 &amp; 次关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%BB%93%E6%9E%84%EF%BC%9A"><span class="toc-number">8.0.3.</span> <span class="toc-text">查找结构：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E4%B9%9F%E5%8F%AB%E7%BA%BF%E6%80%A7%E6%9F%A5%E6%89%BE%EF%BC%89%EF%BC%88%E9%9D%99%E6%80%81%E6%9F%A5%E6%89%BE%EF%BC%89"><span class="toc-number">8.0.3.1.</span> <span class="toc-text">顺序表查找（也叫线性查找）（静态查找）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9C%89%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="toc-number">8.0.3.2.</span> <span class="toc-text">有序表查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%EF%BC%88%E4%BA%8C%E5%88%86%EF%BC%89%E6%9F%A5%E6%89%BE%E6%B3%95%EF%BC%88O-logn-%EF%BC%89"><span class="toc-number">8.0.3.2.1.</span> <span class="toc-text">折半（二分）查找法（O(logn)）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%80%BC%E6%9F%A5%E6%89%BE%E6%B3%95%EF%BC%88%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%E6%94%B9%E8%BF%9B%E7%89%88%EF%BC%9Amid-x3D-low-high-low-key-a-low-x2F-a-high-a-low-%EF%BC%89"><span class="toc-number">8.0.3.2.2.</span> <span class="toc-text">插值查找法（折半查找改进版：mid &#x3D; low+(high-low) * ( (key-a[low]) &#x2F; (a[high]-a[low]) ）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%9F%A5%E6%89%BE%E6%B3%95%EF%BC%88mid-x3D-low-F-k-1-1%EF%BC%89%EF%BC%88%E9%BB%84%E9%87%91%E5%88%86%E5%89%B2%E5%8E%9F%E7%90%86-n-x3D-0-n-x3D-1-n-gt-1%EF%BC%89"><span class="toc-number">8.0.3.2.3.</span> <span class="toc-text">斐波那契查找法（mid&#x3D;low+F[k-1]-1）（黄金分割原理:n&#x3D;0,n&#x3D;1,n&gt;1）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7-x3D-x3D-%E7%B4%A2%E5%BC%95%E8%A1%A8-x3D-x3D-%E6%9F%A5%E6%89%BE%E7%B4%A2%E5%BC%95%EF%BC%9A1-%E7%BA%BF%E6%80%A7%E7%B4%A2%E5%BC%95%EF%BC%88%E8%A1%A8%EF%BC%89-2-%E6%A0%91%E5%BD%A2%E7%B4%A2%E5%BC%95-3-%E5%A4%9A%E7%BA%A7%E7%B4%A2%E5%BC%95"><span class="toc-number">8.0.3.3.</span> <span class="toc-text">线性&#x3D;&#x3D;索引表&#x3D;&#x3D;查找索引：1.线性索引（表） 2.树形索引 3.多级索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%89"><span class="toc-number">8.0.3.4.</span> <span class="toc-text">二叉排序树（二叉查找树）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%EF%BC%88%E6%8E%92%E5%BA%8F%EF%BC%89%E6%A0%91"><span class="toc-number">8.0.3.5.</span> <span class="toc-text">平衡二叉（排序）树</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%9A-%E3%80%8C%E5%8E%9F%E5%88%99%EF%BC%9A%E5%B0%8F%E5%B7%A6%E5%A4%A7%E5%8F%B3%E3%80%8D"><span class="toc-number">8.0.3.6.</span> <span class="toc-text">多路查找树： 「原则：小左大右」</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%91%EF%BC%88%E5%B9%B3%E8%A1%A1%E7%9A%84%E5%A4%9A%E8%B7%AF%E6%9F%A5%E6%89%BE%E6%A0%91%EF%BC%89%EF%BC%88%E4%B8%BA%E5%86%85%E5%A4%96%E5%AD%98%E4%BA%A4%E4%BA%92%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">8.0.3.6.1.</span> <span class="toc-text">B树（平衡的多路查找树）（为内外存交互的数据结构）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3%E6%A0%91%EF%BC%9A%EF%BC%883%E9%98%B6B%E6%A0%91%EF%BC%89-x3D-x3D-gt-2%E6%A0%91%EF%BC%9A1%E5%85%83%E7%B4%A02%E5%AD%A9%E5%AD%90-x2F-NULL-%EF%BC%9B-3%E6%A0%91%EF%BC%9A2%E5%85%83%E7%B4%A03%E5%AD%A9%E5%AD%90-x2F-NULL"><span class="toc-number">8.0.3.6.1.1.</span> <span class="toc-text">2-3树：（3阶B树） &#x3D;&#x3D;&gt; 2树：1元素2孩子&#x2F;NULL ； 3树：2元素3孩子&#x2F;NULL</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-3-4%E6%A0%91%EF%BC%9A%EF%BC%884%E9%98%B6B%E6%A0%91%EF%BC%89-x3D-x3D-gt-3%E5%85%83%E7%B4%A04%E5%AD%A9%E5%AD%90-x2F-NULL"><span class="toc-number">8.0.3.6.1.2.</span> <span class="toc-text">2-3-4树：（4阶B树） &#x3D;&#x3D;&gt; 3元素4孩子&#x2F;NULL</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#m%E9%98%B6B%E6%A0%91"><span class="toc-number">8.0.3.6.1.3.</span> <span class="toc-text">m阶B树</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91%EF%BC%9A%E6%B7%BB%E5%8A%A0%E4%B8%80%E4%B8%AA%E5%85%B3%E9%94%AE%E5%AD%97%E7%B4%A2%E5%BC%95%EF%BC%88B%E6%A0%91%E7%9A%84%E5%8F%98%E5%BD%A2%E6%A0%91%EF%BC%89%EF%BC%88%E4%B8%BA%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E6%89%80%E9%9C%80%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%89"><span class="toc-number">8.0.3.6.2.</span> <span class="toc-text">B+树：添加一个关键字索引（B树的变形树）（为文件系统所需的数据结构）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%EF%BC%88%E7%A9%BA%E9%97%B4%E6%8D%A2%E6%97%B6%E9%97%B4%E3%80%8E%E6%9C%80%E5%A5%BDO-1-%E3%80%8F%EF%BC%89%EF%BC%9A%E4%B8%80%E4%B8%AAkey%EF%BC%88%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%89%E5%AF%B9%E5%BA%94%E4%B8%80%E4%B8%AA-f-key-%EF%BC%88%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%EF%BC%89"><span class="toc-number">8.0.3.7.</span> <span class="toc-text">散列表查找（空间换时间『最好O(1)』）：一个key（关键字）对应一个 f(key)（散列函数）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">8.0.3.7.1.</span> <span class="toc-text">散列函数的构造方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%95%A3%E5%88%97%E5%86%B2%E7%AA%81%EF%BC%9A"><span class="toc-number">8.0.3.7.2.</span> <span class="toc-text">处理散列冲突：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E6%9F%A5%E6%89%BE%E5%AE%9E%E7%8E%B0"><span class="toc-number">8.0.3.7.3.</span> <span class="toc-text">散列表查找实现</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%8E%92%E5%BA%8F"><span class="toc-number">9.</span> <span class="toc-text">九、排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A"><span class="toc-number">9.0.1.</span> <span class="toc-text">排序基本概念：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E7%AE%97%E6%B3%95%E7%B1%BB%EF%BC%9A"><span class="toc-number">9.0.2.</span> <span class="toc-text">简单算法类：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">9.0.2.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%9A%EF%BC%88%E9%80%89%E5%87%BA%E6%9C%80%E5%B0%8F%E5%80%BC%EF%BC%89n-i%E6%AC%A1%E5%85%B3%E9%94%AE%E5%AD%97%E6%AF%94%E8%BE%83%EF%BC%8C%E4%BB%8En-i-1%E4%B8%AA%E8%AE%B0%E5%BD%95%E4%B8%AD%E9%80%89%E5%87%BA%E5%85%B3%E9%94%AE%E5%AD%97%E6%9C%80%E5%B0%8F%E8%AE%B0%E5%BD%95%EF%BC%8C%E4%B8%8Ei%E8%AE%B0%E5%BD%95%E4%BA%A4%E6%8D%A2"><span class="toc-number">9.0.2.2.</span> <span class="toc-text">简单选择排序：（选出最小值）n-i次关键字比较，从n-i+1个记录中选出关键字最小记录，与i记录交换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%88%E9%87%8D%E9%9A%BE%E7%82%B9%EF%BC%89%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%88%E9%80%82%E5%90%88%E5%B1%80%E9%83%A8%E6%9C%89%E5%BA%8F%E5%BA%8F%E5%88%97%EF%BC%89%EF%BC%9A%E6%8F%92%E5%85%A5%E5%88%B0%E5%B7%B2%E6%8E%92%E5%A5%BD%E6%9C%89%E5%BA%8F%E8%A1%A8%E4%B8%AD%EF%BC%8C%E5%BE%97%E5%88%B0%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E3%80%81%E8%AE%B0%E5%BD%95-1%E7%9A%84%E6%9C%89%E5%BA%8F%E8%A1%A8"><span class="toc-number">9.0.2.3.</span> <span class="toc-text">（重难点）直接插入排序（适合局部有序序列）：插入到已排好有序表中，得到一个新的、记录+1的有序表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%EF%BC%88%E9%9A%BE%E7%82%B9%EF%BC%89%E6%94%B9%E8%BF%9B%E7%AE%97%E6%B3%95%E7%B1%BB%EF%BC%9A"><span class="toc-number">9.0.3.</span> <span class="toc-text">（难点）改进算法类：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%88%E5%8D%87%E7%BA%A7%E7%89%88%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%EF%BC%89"><span class="toc-number">9.0.3.1.</span> <span class="toc-text">希尔排序（升级版插入排序）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F%EF%BC%88HeapSort%EF%BC%89%EF%BC%88%E4%BE%9D%E7%85%A7%E7%89%B9%E6%AE%8A%E6%80%A7%E8%B4%A8%E7%9A%84%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%8C%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%80%A7%E8%B4%A85%E3%80%8D%EF%BC%89"><span class="toc-number">9.0.3.2.</span> <span class="toc-text">堆排序（HeapSort）（依照特殊性质的完全二叉树「完全二叉性质5」）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%EF%BC%882%E8%B7%AF%EF%BC%89%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%EF%BC%88%E5%80%92%E7%BD%AE%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%9A%E4%B8%A4%E4%B8%A4%E5%90%88%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%90%8E%E5%86%8D%E5%90%88%E5%B9%B6%EF%BC%89"><span class="toc-number">9.0.3.3.</span> <span class="toc-text">（2路）归并排序（倒置的二叉树：两两合并排序后再合并）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">9.0.3.4.</span> <span class="toc-text">快速排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96%E6%96%B9%E6%A1%88"><span class="toc-number">9.0.3.4.1.</span> <span class="toc-text">快速排序优化方案</span></a></li></ol></li></ol></li></ol></li></ol></li></ol>	
        </div>
    
</div>


    </div>
</div>
</body>

<script src="//cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js"></script>


<script src="//lib.baomitu.com/jquery/1.8.3/jquery.min.js"></script>
<script src="/js/plugin.js"></script>
<script src="/js/typed.js"></script>
<script src="/js/diaspora.js"></script>


<link rel="stylesheet" href="/photoswipe/photoswipe.css">
<link rel="stylesheet" href="/photoswipe/default-skin/default-skin.css">


<script src="/photoswipe/photoswipe.min.js"></script>
<script src="/photoswipe/photoswipe-ui-default.min.js"></script>


<!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">
    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>
    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">
        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>
        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">
            <div class="pswp__top-bar">
                <!--  Controls are self-explanatory. Order can be changed. -->
                <div class="pswp__counter"></div>
                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
                <button class="pswp__button pswp__button--share" title="Share"></button>
                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>
                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>
            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>
            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>
            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>
            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>
        </div>
    </div>
</div>



<script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>




</html>
